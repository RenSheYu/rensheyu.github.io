<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rensheyu.github.io</id>
    <title>_RSY_&apos;s blog</title>
    <updated>2020-02-26T17:04:44.356Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rensheyu.github.io"/>
    <link rel="self" href="https://rensheyu.github.io/atom.xml"/>
    <subtitle>滚落沙尘，泛生浮光。掠影千年，奔走四方。</subtitle>
    <logo>https://rensheyu.github.io/images/avatar.png</logo>
    <icon>https://rensheyu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, _RSY_&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[2020 省选模拟测试 Round #6 solution (20/02/05)]]></title>
        <id>https://rensheyu.github.io/contest-216/</id>
        <link href="https://rensheyu.github.io/contest-216/">
        </link>
        <updated>2020-02-26T16:27:59.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://59.61.75.5:8018/contest/216">【比赛链接】</a></p>
<h2 id="a-旅行">A. 旅行</h2>
<p>【题解】</p>
<p>不难发现，答案即为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 个点和点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 所构成的虚树路径和的两倍减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 个点的最大距离.</p>
<p>两遍 dfs 转移树形 dp 即可.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int inf=1&lt;&lt;30;
const int maxn=500000+10;
struct edge { int v,nxt,w; } e[maxn&lt;&lt;1];
int siz[maxn],h[maxn],cnt,n,k;
bool flag[maxn];
long long f[maxn],g[maxn],max1[maxn],max2[maxn],max[maxn];
inline void dfs ( int u,int fr )
{
	siz[u]=flag[u];max1[u]=flag[u]?0:-inf;max2[u]=-inf;
	for ( int i=h[u];i;i=e[i].nxt ) if ( e[i].v!=fr )
	{
		dfs(e[i].v,u);siz[u]+=siz[e[i].v];
		if ( siz[e[i].v] ) f[u]+=f[e[i].v]+e[i].w;
		if ( max1[e[i].v]+e[i].w&gt;max1[u] ) max2[u]=max1[u],max1[u]=max1[e[i].v]+e[i].w;
		else if ( max1[e[i].v]+e[i].w&gt;max2[u] ) max2[u]=max1[e[i].v]+e[i].w;
	}
}
inline void DFS ( int u,int fr )
{
	for ( int i=h[u];i;i=e[i].nxt ) if ( e[i].v!=fr )
	{
		g[e[i].v]=f[u]+g[u]+e[i].w;
		if ( siz[e[i].v] ) g[e[i].v]-=f[e[i].v]+e[i].w;
		if ( k-siz[e[i].v] )
		{
			max[e[i].v]=max[u]+e[i].w;
			if ( max1[e[i].v]+e[i].w!=max1[u] ) max[e[i].v]=std::max(max[e[i].v],max1[u]+e[i].w);
			else max[e[i].v]=std::max(max[e[i].v],max2[u]+e[i].w);
		}
		DFS(e[i].v,u);
	}
}
signed main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	for ( int i=1,u,v,w;i&lt;n;i++ )
		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w),
		e[++cnt].nxt=h[u],e[h[u]=cnt].v=v,e[cnt].w=w,
		e[++cnt].nxt=h[v],e[h[v]=cnt].v=u,e[cnt].w=w;
	for ( int i=1;i&lt;=n;i++ ) max[i]=-inf;
	for ( int i=1,u;i&lt;=k;i++ ) scanf(&quot;%d&quot;,&amp;u),flag[u]=true,max[u]=0;
	dfs(1,0);DFS(1,0);
	for ( int i=1;i&lt;=n;i++ ) printf(&quot;%lld\n&quot;,(f[i]+g[i])*2-std::max(std::max(max1[i],max2[i]),max[i]));
	return 0;
}
</code></pre>
<h2 id="b-求和">B. 求和</h2>
<p>【题解】</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>i</mi></mrow></msub><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mfrac><mi>i</mi><mi>d</mi></mfrac></msubsup><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mfrac><mi>i</mi><mi>d</mi></mfrac></msubsup><mi>d</mi><msub><mo>∑</mo><mrow><mi>e</mi><mi mathvariant="normal">∣</mi><mi>gcd</mi><mo>⁡</mo><mo>(</mo><mfrac><mi>i</mi><mi>d</mi></mfrac><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow></msub><mi>μ</mi><mo>(</mo><mi>e</mi><mo>)</mo><munderover><mo stretchy="true">=</mo><mspace width="1em"/><mrow><mi>T</mi><mo>=</mo><mi>d</mi><mi>e</mi></mrow></munderover><msub><mo>∑</mo><mrow><mi>T</mi><mi mathvariant="normal">∣</mi><mi>i</mi></mrow></msub><msub><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>T</mi></mrow></msub><mi>d</mi><mi>μ</mi><mo>(</mo><mfrac><mi>T</mi><mi>d</mi></mfrac><mo>)</mo><mo>(</mo><mfrac><mi>i</mi><mi>T</mi></mfrac><msup><mo>)</mo><mn>2</mn></msup><mo>=</mo><msub><mo>∑</mo><mrow><mi>T</mi><mi mathvariant="normal">∣</mi><mi>i</mi></mrow></msub><mi>φ</mi><mo>(</mo><mi>T</mi><mo>)</mo><mo>(</mo><mfrac><mi>i</mi><mi>T</mi></mfrac><msup><mo>)</mo><mn>2</mn></msup><mo>=</mo><msub><mo>∑</mo><mrow><mi>T</mi><mi mathvariant="normal">∣</mi><mi>i</mi></mrow></msub><mi>φ</mi><mo>(</mo><mfrac><mi>i</mi><mi>T</mi></mfrac><mo>)</mo><msup><mi>T</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(i)=\sum\limits_{d|i}\sum\limits_{j=1}^{\frac{i}{d}}\sum\limits_{k=1}^{\frac{i}{d}}d\sum\limits_{e|\gcd(\frac{i}{d},j,k)}\mu(e) \xlongequal[\quad]{T=de}\sum\limits_{T|i}\sum\limits_{d|T}d\mu(\frac{T}{d})(\frac{i}{T})^2=\sum\limits_{T|i}\varphi(T)(\frac{i}{T})^2=\sum\limits_{T|i}\varphi(\frac{i}{T})T^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.15573em;vertical-align:-1.355365em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7500050000000001em;"><span style="top:-2.058995em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.216005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8003650000000002em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-4.101805em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8550857142857142em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.113777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8003649999999998em;"><span style="top:-2.097887em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.000005em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-4.101805em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8550857142857142em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.002113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7500050000000001em;"><span style="top:-1.985435em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mtight">∣</span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mop mtight"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8550857142857142em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.355365em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">μ</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.014108em;"><span style="top:-3.228em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span></span></span></span><span class="svg-align" style="top:-2.7830000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.334em;min-width:0.888em;"><svg width='400em' height='0.334em' viewBox='0 0 400000 334' preserveAspectRatio='xMinYMin slice'><path d='M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z'/></svg></span></span><span style="top:-2.672em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mspace mtight" style="margin-right:1.4285714285714286em;"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.028000000000000025em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.088336em;vertical-align:-1.216005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7500050000000001em;"><span style="top:-2.058995em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.216005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7500050000000001em;"><span style="top:-2.058995em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.216005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">μ</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.071669em;vertical-align:-1.216005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7500050000000001em;"><span style="top:-2.058995em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.216005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.071669em;vertical-align:-1.216005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7500050000000001em;"><span style="top:-2.058995em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.216005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>f</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mo>∑</mo><mrow><mi>T</mi><mi mathvariant="normal">∣</mi><mi>i</mi></mrow></msub><mi>φ</mi><mo>(</mo><mfrac><mi>i</mi><mi>T</mi></mfrac><mo>)</mo><msup><mi>T</mi><mn>2</mn></msup><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>T</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msup><mi>T</mi><mn>2</mn></msup><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo>⌊</mo><mfrac><mi>n</mi><mi>T</mi></mfrac><mo>⌋</mo></mrow></msubsup><mi>φ</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^{n}f(i)=\sum\limits_{i=1}^n\sum\limits_{T|i}\varphi(\frac{i}{T})T^2=\sum\limits_{T=1}^n T^2\sum\limits_{i=1}^{\lfloor\frac{n}{T}\rfloor}\varphi(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5674020000000004em;vertical-align:-1.216005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7500050000000001em;"><span style="top:-2.058995em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.216005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.7211410000000003em;vertical-align:-0.9943359999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.105664em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9943359999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7268050000000001em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-4.101805em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌊</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mclose mtight">⌋</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>.</p>
<p>直接整除分块+杜教筛求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 的前缀和即可.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int maxn=5000000+10;
int n,m=5000000,mod,inv6,inv2;
inline int power ( int x,int y )
{
	int z=1;
	for ( ;y;y&gt;&gt;=1,x=1LL*x*x%mod ) if ( y&amp;1 ) z=1LL*z*x%mod;
	return z;
}
inline int sum ( int x ) { return 1LL*x*(x+1)%mod*(2*x+1)%mod*inv6%mod; }
long long mu[maxn],phi[maxn];
int pr[maxn],tot;
bool flag[maxn];
std::unordered_map&lt;int,long long&gt; map;
inline long long calc ( int n )
{
	if ( n&lt;=m ) return phi[n];
	if ( map.count(n) ) return map[n];
	long long res=0;
	for ( int i=2,j;i&lt;=n;i=j+1 ) j=n/(n/i),res=(res+(j-i+1)%mod*calc(n/i))%mod;
	res=(1LL*n*(n+1)%mod*inv2%mod-res+mod)%mod;
	return map[n]=res;
}
signed main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;mod);inv6=power(6,mod-2);inv2=power(2,mod-2);
	mu[1]=phi[1]=1;
	for ( int i=2;i&lt;=m;i++ )
	{
		if ( !flag[i] ) pr[++tot]=i,mu[i]=-1,phi[i]=i-1;
		for ( int j=1;j&lt;=tot and pr[j]*i&lt;=m;j++ )
		{
			flag[pr[j]*i]=true;
			if ( !(i%pr[j]) ) { mu[pr[j]*i]=0;phi[pr[j]*i]=phi[i]*pr[j];break; }
			mu[pr[j]*i]=-mu[i];phi[pr[j]*i]=phi[i]*(pr[j]-1);
		}
	}
	for ( int i=2;i&lt;=m;i++ ) phi[i]=(phi[i-1]+phi[i])%mod;
	int ans=0;
	for ( int i=1,j;i&lt;=n;i=j+1 ) j=n/(n/i),ans=(ans+1LL*sum(n/i)*(calc(j)-calc(i-1)+mod))%mod;
	return !printf(&quot;%d\n&quot;,ans);
}
</code></pre>
<h2 id="c-递增">C. 递增</h2>
<p>【题解】</p>
<p>考虑先将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l,r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 离散化. 为了处理方便离散化所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r_i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。记离散化后的权值数组为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">val_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对应区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>v</mi><mi>a</mi><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>v</mi><mi>a</mi><msub><mi>l</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[val_i,val_{i+1}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>.</p>
<p>显然原来的每段可以拆分成若干个小区间. 根据题目要求，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 所在的小区间编号单调不降.</p>
<p>考虑 dp，记 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个元素，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个元素在第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个小区间内的元素和. 显然可以枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">k,l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{k,l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 转移.</p>
<p>考虑转移. 根据转移，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[k+1,i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 中的元素都必须在区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>v</mi><mi>a</mi><msub><mi>l</mi><mi>j</mi></msub><mo separator="true">,</mo><mi>v</mi><mi>a</mi><msub><mi>l</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[val_j,val_{j+1}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 内. 记元素的取值范围区间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[L,R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span>，共需要取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mi>i</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">t=i-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个元素.</p>
<p>显然转移的方案数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>=</mo><msubsup><mi>C</mi><mrow><mi>R</mi><mo>−</mo><mi>L</mi><mo>+</mo><mi>t</mi></mrow><mi>t</mi></msubsup></mrow><annotation encoding="application/x-tex">cnt=C_{R-L+t}^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.127218em;vertical-align:-0.333662em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.424669em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">L</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.333662em;"><span></span></span></span></span></span></span></span></span></span>，根据数列相关知识，所有转移方案的权值总和为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>=</mo><mi>t</mi><mo>×</mo><mfrac><mrow><mi>L</mi><mo>+</mo><mi>R</mi></mrow><mn>2</mn></mfrac><mo>×</mo><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">sum=t \times \frac{L+R}{2} \times cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>.</p>
<p>发现无法直接转移，因此需记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个元素，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个元素在第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个小区间内的方案数.</p>
<p>则有：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mo>∑</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>×</mo><msub><mi>f</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo>+</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>∗</mo><msub><mi>g</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo separator="true">,</mo><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mo>∑</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>×</mo><msub><mi>g</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=\sum cnt \times f_{k,l}+sum*g_{k,l},g_{i,j}=\sum cnt \times g_{k,l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>. 直接转移即可.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>4</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const long long mod=998244353,inv2=(mod+1)&gt;&gt;1;
std::set&lt;long long&gt; s;
std::unordered_map&lt;long long,int&gt; map;
int n,tot,L[500],R[500];
long long l[500],r[500],val[500],f[500][500],g[500][500],ans,inv[500];
inline long long C ( long long x,int y )
{
	long long res=inv[y];
	for ( int i=1;i&lt;=y;i++ ) (res*=(x-i+1)%mod)%=mod;
	return res;
}
signed main()
{
	scanf(&quot;%d&quot;,&amp;n);inv[0]=inv[1]=1;
	for ( int i=1;i&lt;=n;i++ ) scanf(&quot;%lld&quot;,&amp;l[i]),s.insert(l[i]);
	for ( int i=1;i&lt;=n;i++ ) scanf(&quot;%lld&quot;,&amp;r[i]),s.insert(r[i]+1);
	for ( int i=2;i&lt;=n;i++ ) inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for ( int i=2;i&lt;=n;i++ ) (inv[i]*=inv[i-1])%=mod;
	for ( long long x:s ) val[map[x]=++tot]=x;
	for ( int i=1;i&lt;=n;i++ ) L[i]=map[l[i]],R[i]=map[r[i]+1]-1;
	g[0][0]=1;
	for ( int i=1;i&lt;=n;i++ ) for ( int j=L[i];j&lt;=R[i];j++ )
	{
		for ( int k=0;k&lt;i;k++ )
		{
			bool flag=true;
			for ( int p=k+1;p&lt;=i;p++ ) flag&amp;=(L[p]&lt;=j and j&lt;=R[p]);
			if ( !flag ) continue;
			int t=i-k;
			long long pL=val[j],pR=val[j+1]-1,cnt=C(pR-pL+t,t);
			long long res=(pL+pR)%mod*t%mod*inv2%mod*cnt%mod;
			for ( int l=0;l&lt;j;l++ ) (f[i][j]+=cnt*f[k][l]+g[k][l]*res)%=mod,(g[i][j]+=cnt*g[k][l])%=mod;
		}
	}
	for ( int i=L[n];i&lt;=R[n];i++ ) (ans+=f[n][i])%=mod;
	return !printf(&quot;%lld\n&quot;,ans);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 省选模拟测试 Round #7 solution (20/02/06)（C题坑待填）]]></title>
        <id>https://rensheyu.github.io/contest-217/</id>
        <link href="https://rensheyu.github.io/contest-217/">
        </link>
        <updated>2020-02-26T16:17:01.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://59.61.75.5:8018/contest/217">【比赛链接】</a></p>
<h2 id="a-异或">A. 异或</h2>
<p>【题解】</p>
<p>考虑拆成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>r</mi></msubsup><mi>f</mi><mo>(</mo><mi>i</mi><mo>⊕</mo><mi>x</mi><msup><mo>)</mo><mn>2</mn></msup><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>f</mi><mo>(</mo><mi>i</mi><mo>⊕</mo><mi>x</mi><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sum_{i=0}^r f(i\oplus x)^2 - \sum_{i=0}^{l-1} f(i\oplus x)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 两部分进行求解.</p>
<p>根据异或的性质，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[0,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 间的数在异或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 后应拆分为最多 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 段，逐位拆分，每段分别计算.</p>
<p>考虑每段的答案仍然采用前缀和相减. 二分查找对应的位置即可. 细节详见代码.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msup><mi>log</mi><mo>⁡</mo><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log^2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int mod=998244353;
const int maxn=100000+10;
int a[maxn],val[maxn],cnt[maxn],tot,n,Q;
long long sum[maxn];
std::set&lt;int&gt; s;
std::map&lt;int,int&gt; map;
inline int ask ( int x )
{
	int pos=std::upper_bound(val+1,val+tot+1,x)-val-1;
	return (!pos) ? 0 : (sum[pos-1]+1LL*(x-val[pos]+1)%mod*cnt[pos]%mod*cnt[pos]%mod)%mod;
}
inline int Ask ( int l,int r ) { return (ask(r)-ask(l-1)+mod)%mod; }
inline int query ( int p,int x )
{
	if ( p&lt;0 ) return 0;
	int u=0,ans=0;
	for ( int i=30;~i;i-- )
	{
		int k=(x&gt;&gt;i)&amp;1;
		if ( (p&gt;&gt;i)&amp;1 ) ans=(ans+Ask(u|(k&lt;&lt;i),(u|(k&lt;&lt;i))+(1&lt;&lt;i)-1))%mod,u+=(k^1)&lt;&lt;i;
		else u|=k&lt;&lt;i;
	}
	return (ans+Ask(u,u))%mod;
}
signed main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;Q);
	for ( int i=1;i&lt;=n;i++ ) scanf(&quot;%d&quot;,&amp;a[i]),s.insert(a[i]);
	for ( int x:s ) val[map[x]=++tot]=x;
	for ( int i=1;i&lt;=n;i++ ) cnt[map[a[i]]]++;
	for ( int i=1;i&lt;=tot;i++ ) cnt[i]+=cnt[i-1];
	for ( int i=1;i&lt;=tot;i++ ) sum[i]=(sum[i-1]+1LL*(val[i+1]-val[i])%mod*cnt[i]%mod*cnt[i]%mod)%mod;
	for ( int l,r,x;Q--; ) scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x),printf(&quot;%d\n&quot;,(query(r,x)-query(l-1,x)+mod)%mod);
    return 0;
} 
</code></pre>
<h2 id="b-点分治">B. 点分治</h2>
<p>【题解】</p>
<p>考虑树形 dp. 设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的子树进行点分治，并且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 在点分树中的深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的方案数.</p>
<p>把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的儿子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的 dp 数组合并上来时有：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mi>i</mi><mo>−</mo><mi>j</mi></mrow><mi>n</mi></msubsup><mi>f</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>×</mo><mi>f</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>×</mo><msubsup><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">f&#x27;[x][i]=\sum_{j=1}^i\sum_{k=i-j}^n f[x][j]\times f[y][k]\times C_{i-1}^{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400382em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.964564em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2777669999999999em;vertical-align:-0.335195em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.942572em;"><span style="top:-2.423136em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.335195em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p>预处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 的后缀和，直接转移即可.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
const int mod=1000000007;
int n,f[5010][5010],siz[5010],g[5010],h[5010],C[5010][5010];
std::vector&lt;int&gt; e[5010];
inline void dfs ( int u,int fr )
{
	f[u][1]=siz[u]=1;
	for ( int v:e[u] ) if ( v!=fr )
	{
		dfs(v,u);
		for ( int y=n;~y;y-- ) h[y]=(h[y+1]+f[v][y])%mod;
		for ( int x=1;x&lt;=siz[u]+siz[v];x++ ) g[x]=0;
		for ( int x=1;x&lt;=siz[u];x++ ) for ( int y=0;y&lt;=siz[v];y++ ) g[x+y]=(g[x+y]+1LL*f[u][x]*h[y]%mod*C[x+y-1][x-1])%mod;
		siz[u]+=siz[v];
		for ( int x=1;x&lt;=siz[u];x++ ) f[u][x]=g[x];
	}
}
signed main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for ( int i=1,u,v;i&lt;n;i++ ) scanf(&quot;%d%d&quot;,&amp;u,&amp;v),e[u].push_back(v),e[v].push_back(u);
	for ( int i=0;i&lt;=n;i++ )
	{
		C[i][0]=1;
		for ( int j=1;j&lt;=i;j++ ) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	}
	dfs(1,0);int Ans=0;
	for ( int i=1;i&lt;=n;i++ ) Ans=(Ans+f[1][i])%mod;
	return !printf(&quot;%d\n&quot;,Ans);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 省选模拟测试 Round #8 solution (20/02/07)（B题坑待填）]]></title>
        <id>https://rensheyu.github.io/contest-218/</id>
        <link href="https://rensheyu.github.io/contest-218/">
        </link>
        <updated>2020-02-26T16:13:22.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://59.61.75.5:8018/contest/218">【比赛链接】</a></p>
<h2 id="a-并">A. 并</h2>
<p>【题解】</p>
<p>考虑每个点什么时候会被统计. 显然每次包含其连通块的操作都会影响. 将操作反序处理，统计一下即可.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
int n,m,u[500010],v[500010],s[500010],val[500010],q[500010];
signed main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for ( int i=1;i&lt;n;i++ ) scanf(&quot;%d%d&quot;,&amp;u[i],&amp;v[i]);
	for ( int i=1;i&lt;=n;i++ ) s[i]=1;
	for ( int i=1;i&lt;=m;i++ ) scanf(&quot;%d&quot;,&amp;q[i]);
	for ( int i=m,x;i;i-- ) x=q[i],s[u[x]]=s[v[x]]=s[u[x]]+s[v[x]]-val[x],val[x]=s[u[x]];
	for ( int i=1;i&lt;=n;i++ ) printf(&quot;%d%c&quot;,s[i],&quot; \n&quot;[i==n]);
	return 0;
}
</code></pre>
<h2 id="c-管理">C. 管理</h2>
<p>【题解】</p>
<p>考虑 dp. 设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个数分为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 段的最小值. 则有：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><msub><mi>min</mi><mo>⁡</mo><mrow><mn>0</mn><mo>≤</mo><mi>k</mi><mo>&lt;</mo><mi>i</mi></mrow></msub><mo>(</mo><mi>f</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>w</mi><mo>(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f[i][j]=\min\limits_{0\leq k &lt;i}(f[k][j-1]+w(k+1,i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.597287em;vertical-align:-0.8472869999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.047892em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8472869999999999em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>.</p>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 较小，显然可以分层处理，即对每一层 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 分别转移.</p>
<p>打表发现具有决策单调性. 又无法用指针或单调队列维护具体情况，考虑用分治法处理决策单调性.</p>
<p>考虑如何计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">w(l,r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>. 显然可以由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">w(l,r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> 推至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>(</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">w(l-1,r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> 等类似位置. 因此用类似莫队的方法进行维护即可.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>k</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nk\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const long long inf=1LL&lt;&lt;60;
int n,k,cnt[100010],a[100010],pl,pr;
long long f[100010][22],res;
inline void Ins ( int x,int v ) { res-=1LL*cnt[x]*(cnt[x]-1)/2;cnt[x]+=v;res+=1LL*cnt[x]*(cnt[x]-1)/2; }
inline void solve ( int l,int r,int L,int R,int k )
{
	int mid=(l+r)&gt;&gt;1;
	while ( pl&gt;L+1 ) Ins(a[--pl],1);
	while ( pr&lt;mid ) Ins(a[++pr],1);
	while ( pl&lt;L+1 ) Ins(a[pl++],-1);
	while ( pr&gt;mid ) Ins(a[pr--],-1);
	int p=L;long long ans=f[L][k-1]+res;
	while ( pl&lt;=mid and pl&lt;=R+1 )
	{
		if ( f[pl-1][k-1]+res&lt;=ans ) ans=f[pl-1][k-1]+res,p=pl-1;
		Ins(a[pl++],-1);
	}
	f[mid][k]=ans;
	if ( l&lt;=mid-1 ) solve(l,mid-1,L,p,k);
	if ( mid+1&lt;=r ) solve(mid+1,r,p,R,k);
}
signed main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	for ( int i=1;i&lt;=n;i++ ) scanf(&quot;%d&quot;,&amp;a[i]);
	for ( int i=0;i&lt;=n;i++ ) for ( int j=0;j&lt;=k;j++ ) f[i][j]=inf;
	f[0][0]=0;
	for ( int j=1;j&lt;=k;j++ )
	{
		res=0;pl=1;pr=n;
		for ( int i=1;i&lt;=n;i++ ) cnt[i]=0;
		for ( int i=1;i&lt;=n;i++ ) Ins(a[i],1);
		solve(1,n,0,n-1,j);
	}
	return !printf(&quot;%lld\n&quot;,f[n][k]);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 省选模拟测试 Round #9 solution (20/02/08)]]></title>
        <id>https://rensheyu.github.io/contest-219/</id>
        <link href="https://rensheyu.github.io/contest-219/">
        </link>
        <updated>2020-02-26T16:06:55.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://59.61.75.5:8018/contest/219">【比赛链接】</a></p>
<h2 id="a-树">A. 树</h2>
<p>【题解】</p>
<p>手算一遍样例，就大概清楚题目的做法了. 显然每条路径在一段上贡献的答案是一个等差数列，在三个节点处打上标记，差分即可。细节详见代码.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，瓶颈在于求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">lca</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int maxn=300000+10;
int dep[maxn],Log[maxn],p[maxn][22],n;
long long ans[maxn],res[maxn],Ans;
std::vector&lt;int&gt; e[maxn];
inline int lca ( int u,int v )
{
	if ( dep[u]&lt;dep[v] ) std::swap(u,v);
	for ( int i=Log[dep[u]];~i;i-- ) if ( dep[p[u][i]]&gt;=dep[v] ) u=p[u][i];
	if ( u==v ) return u;
	for ( int i=Log[dep[u]];~i;i-- ) if ( p[u][i]!=p[v][i] ) u=p[u][i],v=p[v][i];
	return p[u][0];
}
inline void dfs ( int u,int fr )
{
	dep[u]=dep[p[u][0]=fr]+1;
	for ( int i=1;p[u][i-1];i++ ) p[u][i]=p[p[u][i-1]][i-1];
	for ( int v:e[u] ) if ( v!=fr ) dfs(v,u);
}
inline void solve ( int u,int fr )
{
	for ( int v:e[u] ) if ( v!=fr ) solve(v,u),ans[u]+=ans[v],res[u]+=res[v];
}
inline void calc ( int u,int fr )
{
	ans[u]=ans[u]*dep[u]+res[u]+ans[fr];
	for ( int v:e[u] ) if ( v!=fr ) calc(v,u);
}
signed main()
{
	freopen(&quot;tree.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;tree.out&quot;,&quot;w&quot;,stdout);
	int m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for ( int i=2,u,v;i&lt;=n;i++ ) scanf(&quot;%d%d&quot;,&amp;u,&amp;v),e[u].push_back(v),e[v].push_back(u),Log[i]=Log[i&gt;&gt;1]+1;
	dfs(1,0);
	for ( int u,v,l;m--; )
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v),l=lca(u,v),
		ans[u]-=2,res[u]+=2*dep[l]-dep[v]+dep[u]+1,
		ans[v]-=2,res[v]+=2*dep[l]-dep[u]+dep[v]+1,
		ans[l]+=4,res[l]-=4*dep[l]+2,
		Ans+=1LL*(dep[u]-dep[l])*(dep[v]-dep[l]);
	solve(1,0);calc(1,0);
	for ( int i=1;i&lt;=n;i++ ) printf(&quot;%lld\n&quot;,ans[i]+Ans);
	return 0;
}
</code></pre>
<h2 id="b-方程">B. 方程</h2>
<p>【题解】</p>
<p>同样手算一遍样例. 发现显然可以逐位贪心，若首位不为0则显然后面的位置可以随意选来补齐.</p>
<p>因此考虑逐位 dp. 设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个最高位为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的数选了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个的方案数. 转移方程参见代码.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>T</mi><mo>×</mo><mn>31</mn><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(T \times 31n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int mod=1000000007;
int n,k,a[100],f[100][100],ans;
inline int power ( int x,int y )
{
	int z=1;
	for ( ;y;y&gt;&gt;=1,x=1LL*x*x%mod ) if ( y&amp;1 ) z=1LL*z*x%mod;
	return z;
}
signed main()
{
	while ( ~scanf(&quot;%d%d&quot;,&amp;n,&amp;k) )
	{
		int m=0;
		for ( int i=1;i&lt;=n;i++ ) scanf(&quot;%d&quot;,&amp;a[i]),m^=a[i];
		ans=(m==k);
		for ( int i=30;~i;i-- ) if ( (m&gt;&gt;(i+1))==(k&gt;&gt;(i+1)) )
		{
			for ( int j=0;j&lt;=n;j++ ) for ( int l=0;l&lt;=n;l++ ) f[j][l]=0;
			f[0][0]=1;
			for ( int j=1;j&lt;=n;j++ )
			{
				for ( int l=0;l&lt;=n;l++ ) f[j][l]=(f[j][l]+1LL*(f[j-1][l]*(1+a[j]%(1&lt;&lt;i))))%mod;
				if ( (a[j]&gt;&gt;i)&amp;1 ) for ( int l=0;l&lt;=n;l++ ) f[j][l+1]=(f[j][l+1]+f[j-1][l])%mod;
			}
			for ( int j=1;j&lt;=n;j++ ) if ( ((j^(m&gt;&gt;i)^(k&gt;&gt;i))&amp;1)^1 ) ans=(ans+1LL*power((1&lt;&lt;i)%mod,j-1)*f[n][j])%mod;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<h2 id="c-圈">C. 圈</h2>
<p>【题解】</p>
<p>考虑题目的限制：度数大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>.</p>
<p>这个性质不好用，考虑改造，使度数等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>.</p>
<p>先把哈密顿回路扔出来，作为第一个圈.</p>
<p>若一个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 有不在哈密顿回路上的边有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>z</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y),(x,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>，我们新建⽴立一个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>，假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 在哈密顿回路上下一个点是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，则把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>w</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> 拆成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>p</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>w</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,p),(p,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>z</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>z</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(p,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>. 我们对这个图求完圈覆盖后，只要把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">x,p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span> 变回同一个点，且缩掉 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span> 即可。至此转化完毕.</p>
<p>此时只剩下偶数个点. 将哈密顿回路上的边分为两类，分别匹配一遍即可. 分法很多，可采用如下办法：所有匹配边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mo>{</mo><mo>(</mo><mn>2</mn><mi>i</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>}</mo></mrow><annotation encoding="application/x-tex">+\{(2i,2i+1)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">+</span><span class="mopen">{</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span> 与所有匹配边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mo>{</mo><mo>(</mo><mn>2</mn><mi>i</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>}</mo></mrow><annotation encoding="application/x-tex">+\{(2i,2i-1)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">+</span><span class="mopen">{</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span>.</p>
<p>考虑具体实现，将边黑白染色即可，而不用写出拆边的代码.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
inline int read ( void )
{
	int x=0;char ch;
	while ( !isdigit(ch=getchar()) ) ;
	for ( x=ch^48;isdigit(ch=getchar()); ) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
	return x;
}
struct edge { int v,x; } G[1000][1000];
std::vector&lt;std::vector&lt;int&gt;&gt; Circles;
std::vector&lt;int&gt; Cir;
int n,m,siz[1000],map[1000][1000];
bool vis[1000][1000];
inline edge Next ( int u,int x )
{
	if ( x!=siz[u] ) return (edge){u,x+1};
	if ( u==n ) return (edge){1,1};
	return (edge){u+1,1};
}
inline edge Prev ( int u,int x )
{
	if ( x!=1 ) return (edge){u,x-1};
	if ( u==1 ) return (edge){n,siz[n]};
	return (edge){u-1,siz[u-1]};
}
inline void Ins ( int u )
{
	if ( (int)Cir.size() and Cir[(int)Cir.size()-1]==u ) return;
	Cir.push_back(u);
}
inline void dfs ( int u,int x,int k )
{
	vis[u][x]=true;Ins(u);bool f=(map[u][x]==k);
	edge w=f?Next(u,x):Prev(u,x);Ins(w.v);
	while ( w.x==1 ) w=(f?Next(w.v,w.x):Prev(w.v,w.x)),Ins(w.v);
	u=w.v;x=w.x;Ins(u);vis[u][x]=true;w=G[u][x];u=w.v;x=w.x;
	if ( !vis[u][x] ) Ins(u),vis[u][x]=true,dfs(u,x,k);
}
signed main()
{
	for ( int T=read();T--; )
	{
		Circles.clear();n=read();m=read();
		for ( int i=1;i&lt;=n;i++ ) for ( int j=1;j&lt;=m;j++ ) G[i][j]=(edge){0,0};
		for ( int i=1;i&lt;=n;i++ ) siz[i]=1;
		for ( int i=1;i&lt;=m;i++ )
		{
			int u=read(),v=read();
			if ( u&gt;v ) std::swap(u,v);
			if ( v==u+1 ) continue;
			if ( u==1 and v==n ) continue;
			++siz[u];++siz[v];
			G[u][siz[u]]=(edge){v,siz[v]};
			G[v][siz[v]]=(edge){u,siz[u]};
		}
		for ( int i=1;i&lt;=n;i++ ) Cir.push_back(i);
		Circles.push_back(Cir);Cir.clear();
		int k=0;
		for ( int i=1;i&lt;=n;i++ ) for ( int j=2;j&lt;=siz[i];j++ ) k^=1,map[i][j]=k;
		for ( int i=1;i&lt;=n;i++ ) for ( int j=1;j&lt;=siz[i];j++ ) vis[i][j]=false;
		for ( int i=1;i&lt;=n;i++ ) for ( int j=2;j&lt;=siz[i];j++ ) if ( !vis[i][j] ) dfs(i,j,1),Circles.push_back(Cir),Cir.clear();
		for ( int i=1;i&lt;=n;i++ ) for ( int j=1;j&lt;=siz[i];j++ ) vis[i][j]=false;
		for ( int i=1;i&lt;=n;i++ ) for ( int j=2;j&lt;=siz[i];j++ ) if ( !vis[i][j] ) dfs(i,j,0),Circles.push_back(Cir),Cir.clear();
		printf(&quot;%d\n&quot;,(int)Circles.size());
		for ( auto Circle:Circles )
		{
			printf(&quot;%d&quot;,(int)Circle.size());
			for ( int x:Circle ) printf(&quot; %d&quot;,x);
			puts(&quot;&quot;);
		}
	}
	return 0;
}
</code></pre>
<h2 id="d-期望逆序对">D. 期望逆序对</h2>
<p>【题解】</p>
<p>显然按中点排序即可. 证明自行理解.</p>
<p>统计直接枚举两个区间算贡献，记得预处理长度逆元保证复杂度.</p>
<p>其实也可以用线段树或树状数组维护每个值的期望个数，可以减小复杂度.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int mod=998244353,inv2=(mod+1)&gt;&gt;1;
struct Pair { int l,r; } p[5010];
int n,inv[5010],ans,len[5010];
inline int power ( int x,int y )
{
	int z=1;
	for ( ;y;y&gt;&gt;=1,x=1LL*x*x%mod ) if ( y&amp;1 ) z=1LL*z*x%mod;
	return z;
}
signed main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for ( int i=1;i&lt;=n;i++ ) scanf(&quot;%d%d&quot;,&amp;p[i].l,&amp;p[i].r);
	std::sort(p+1,p+n+1,[&amp;](const Pair &amp;p1,const Pair &amp;p2){return p1.l+p1.r&lt;p2.l+p2.r;});
	for ( int i=1;i&lt;=n;i++ ) len[i]=p[i].r-p[i].l+1,inv[i]=power(p[i].r-p[i].l+1,mod-2);
	for ( int i=1;i&lt;n;i++ ) for ( int j=i+1;j&lt;=n;j++ )
	{
		if ( p[i].l&lt;=p[j].l and p[j].r&lt;=p[i].r )
			ans=(ans+1LL*len[j]*(len[j]-1)/2%mod*inv[i]%mod*inv[j]%mod+1LL*(p[i].r-p[j].r)*len[j]%mod*inv[i]%mod*inv[j]%mod)%mod;
		else if ( p[j].l&lt;=p[i].l and p[i].r&lt;=p[j].r )
			ans=(ans+1LL*len[i]*(len[i]-1)/2%mod*inv[i]%mod*inv[j]%mod+1LL*(p[i].l-p[j].l)*len[i]%mod*inv[i]%mod*inv[j]%mod)%mod;
		else if ( p[i].l&lt;=p[j].l and p[j].l&lt;=p[i].r )
			ans=(ans+1LL*(p[i].r-p[j].l+1)*(p[i].r-p[j].l)/2%mod*inv[i]%mod*inv[j]%mod)%mod;
	}
	return !printf(&quot;%d\n&quot;,ans);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 省选模拟测试 Round #10 solution (20/02/09)]]></title>
        <id>https://rensheyu.github.io/contest-220/</id>
        <link href="https://rensheyu.github.io/contest-220/">
        </link>
        <updated>2020-02-26T12:03:59.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://59.61.75.5:8018/contest/220">【比赛链接】</a></p>
<h2 id="a-逆序对">A. 逆序对</h2>
<p>【题解】</p>
<p>一般这种 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次方和的题目可以用插值的方法做，其中最经典的就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msup><mi>i</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^{n} i^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>. 本题类似.</p>
<p>考虑 dp，设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 为大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>、逆序对个数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的排列个数. 转移有：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=\sum\limits_{k=0}^{i-1}f_{i-1,j-k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.513782em;vertical-align:-1.002113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.511669em;"><span style="top:-2.097887em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.000005em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.002113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p>记 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mfrac><mrow><mi>i</mi><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></msubsup><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><msup><mi>j</mi><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">g_i=\sum_{j=0}^{\frac{i(i-1)}{2}} f_{i,j}j^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7250219999999998em;vertical-align:-0.4129719999999999em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.31205em;"><span style="top:-2.7231360000000002em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.5856000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0377857142857143em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.5020714285714285em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4129719999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span>. 可以证明，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msub><mi>g</mi><mi>n</mi></msub><mrow><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mi>K</mi><mo>)</mo><mo>!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{g_n}{(n-2K)!}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2675em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mclose mtight">)</span><span class="mclose mtight">!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 是个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>K</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span> 阶多项式，直接插值即可.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><msup><mi>k</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n+k^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int mod=1000000007;
int inv[500],f[500][80010],n,k,Y[500],ans;
inline int power ( int x,int y )
{
	int z=1;
	for ( ;y;y&gt;&gt;=1,x=1LL*x*x%mod ) if ( y&amp;1 ) z=1LL*z*x%mod;
	return z;
}
signed main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	f[0][0]=inv[0]=inv[1]=1;
	for ( int i=1;i&lt;=4*k;i++ ) for ( int j=0;j&lt;=i*(i-1)/2;j++ )
	{
		if ( j ) f[i][j]=f[i][j-1];
		f[i][j]=(f[i][j]+f[i-1][j])%mod;
		if ( j&gt;=i ) f[i][j]=(f[i][j]-f[i-1][j-i]+mod)%mod;
	}
	for ( int i=2;i&lt;=4*k;i++ ) inv[i]=1LL*inv[mod%i]*(mod-mod/i)%mod;
	for ( int i=3;i&lt;=4*k;i++ ) inv[i]=1LL*inv[i-1]*inv[i]%mod;
	for ( int i=1;i&lt;=4*k;i++ )
	{
		int res=0;
		for ( int j=0;j&lt;=i*(i-1)/2;j++ ) res=(res+1LL*f[i][j]*power(j,k))%mod;
		Y[i]=1LL*res*inv[i]%mod;
	}
	if ( n&lt;=4*k ) ans=Y[n];
	else for ( int i=1;i&lt;=4*k;i++ )
	{
		int val=1;
		for ( int j=1;j&lt;=4*k;j++ ) if ( j!=i ) val=1LL*val*(n-j)%mod*power((i-j+mod)%mod,mod-2)%mod;
		ans=(ans+1LL*val*Y[i])%mod;
	}
	for ( int i=1;i&lt;=n;i++ ) ans=1LL*ans*i%mod;
	return !printf(&quot;%d\n&quot;,ans);
}
</code></pre>
<h2 id="b-线段树">B. 线段树</h2>
<p>【题解】</p>
<p>显然考虑区间 dp，考虑选择区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 的权值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">w[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>.</p>
<p>分类讨论询问区间与选择区间的相交情况，前缀和后缀和记录一下即可.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
int n,m,L[600],R[600],cnt[600],sum[600],val[600],w[600][600],f[600][600];
std::vector&lt;int&gt; G[600];
signed main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for ( int x,y,Q=m;Q--; ) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),L[x]++,R[y]++,cnt[x]++,cnt[y+1]--,G[y].push_back(x);
	for ( int i=1;i&lt;=n;i++ ) cnt[i]+=cnt[i-1],R[i]+=R[i-1];
	for ( int i=n;i;i-- ) L[i]+=L[i+1];
	for ( int r=n;r;r-- )
	{
		for ( int x:G[r] ) val[x]++;
		for ( int l=1;l&lt;r;l++ ) sum[l]=sum[l-1]+val[l];
		for ( int l=1;l&lt;r;l++ ) w[l][r]=m-2*sum[l]-R[l-1]-L[r+1];
	}
	for ( int i=1;i&lt;=n;i++ ) f[i][i]=cnt[i];
	for ( int r=2;r&lt;=n;r++ ) for ( int l=r-1;l;l-- )
	{
		f[l][r]=1&lt;&lt;29;
		for ( int k=l;k&lt;r;k++ ) f[l][r]=std::min(f[l][r],f[l][k]+f[k+1][r]+w[l][r]);
	}
	return !printf(&quot;%d\n&quot;,f[1][n]);
}
</code></pre>
<h2 id="c-道路修建">C. 道路修建</h2>
<p>【题解】</p>
<p><s>计算几何永远放T3</s></p>
<p>显然是类似平面图分治的做法.</p>
<p>考虑先求出凸包，分析凸包上的点的颜色分布情况.</p>
<p>如果凸包上的点颜色段超过两段，可以（画图）证明无解.</p>
<p>考虑只有两段的情况，根据平面图分治的思想，进行三角剖分，对每个三角形分别解决.</p>
<p>考虑如何三角剖分：若三角形三个顶点同色，则这种剖分是无意义的，可能导致无解.</p>
<p>考虑强制使三个点异色，在凸包上的两个颜色连续段分别将每条线段与另一个颜色连续段的首个点连边构成三角形，画图发现这样可以满足条件.</p>
<p>对于凸包上的点全部同色的情况，可以在凸包内找一个点，向每条凸包上的线段连边构成三角形.</p>
<p>现在考虑三角形如何处理，设三角形顶点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">u,v,w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 是颜色不同的点.</p>
<p>考虑三角形中点的颜色，如果全部与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo separator="true">,</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">v,w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 同色则直接连边即可.</p>
<p>若存在一个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 同色，分治 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo separator="true">,</mo><mi>p</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>w</mi><mo separator="true">,</mo><mi>u</mi><mo separator="true">,</mo><mi>p</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(v,u,p),(w,u,p),(p,v,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> 三部分即可.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
inline int read ( void )
{
	int x=0;char ch;bool f=true;
	while ( !isdigit(ch=getchar()) ) if ( ch=='-' ) f=false;
	for ( x=ch^48;isdigit(ch=getchar()); ) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
	return f ? x : -x ;
}
typedef struct { int x,y,c,id; } Point;
std::vector&lt;Point&gt; G,B;
std::vector&lt;std::pair&lt;Point,Point&gt;&gt; Ans;
Point st[3010];
inline long long cross ( Point u,Point v,Point w ) { return 1LL*(u.x-w.x)*(v.y-w.y)-1LL*(u.y-w.y)*(v.x-w.x); }
inline bool operator == ( Point u,Point v ) { return u.c==v.c and u.id==v.id ; }
inline bool Inside ( Point p,Point u,Point v,Point w )
{
	if ( p==u or p==v or p==w ) return false;
	bool f_uv=cross(u,v,p)&gt;0,f_vw=cross(v,w,p)&gt;0,f_wu=cross(w,u,p)&gt;0;
	return f_uv==f_vw and f_vw==f_wu ;
}
inline void solve ( std::vector&lt;Point&gt; Points,Point u,Point v,Point w )
{
	if ( Points.empty() ) return;
	Point pos=(Point){0,0,0,-1};
	for ( auto p:Points ) if ( p.c==u.c ) { pos=p;break; }
	if ( ~pos.id )
	{
		Ans.push_back(std::make_pair(u,pos));
		std::vector&lt;Point&gt; Points_uv,Points_vw,Points_wu;
		for ( auto p:Points )
			if ( Inside(p,u,v,pos) ) Points_uv.push_back(p);
			else if ( Inside(p,v,w,pos) ) Points_vw.push_back(p);
			else if ( Inside(p,w,u,pos) ) Points_wu.push_back(p);
		solve(Points_uv,v,u,pos);
		solve(Points_wu,w,u,pos);
		solve(Points_vw,pos,v,w);
		return;
	}
	for ( auto p:Points ) Ans.push_back(std::make_pair(w,p));
}
signed main()
{
	int cntA=read(),cntB=read(),tp=0;
	for ( int i=1,x,y;i&lt;=cntA;i++ ) x=read(),y=read(),G.push_back((Point){x,y,0,i});
	for ( int i=1,x,y;i&lt;=cntB;i++ ) x=read(),y=read(),G.push_back((Point){x,y,1,i});
	std::sort(G.begin(),G.end(),[&amp;](const Point &amp;p1,const Point &amp;p2){return p1.x==p2.x ? p1.y&lt;p2.y : p1.x&lt;p2.x;});
	st[tp=1]=G[0];
	for ( auto p:G )
	{
		while ( tp&gt;1 and cross(p,st[tp],st[tp-1])&lt;=0 ) tp--;
		st[++tp]=p;
	}
	for ( int i=1;i&lt;=tp;i++ ) B.push_back(st[i]);
	st[tp=1]=G[0];
	for ( auto p:G )
	{
		while ( tp&gt;1 and cross(p,st[tp],st[tp-1])&gt;=0 ) tp--;
		st[++tp]=p;
	}
	for ( int i=tp-1;i&gt;=2;i-- ) B.push_back(st[i]);
	int Dcnt=(B[0].c!=B[(int)B.size()-1].c);
	for ( int i=1;i&lt;(int)B.size();i++ ) if ( B[i].c!=B[i-1].c ) Dcnt++;
	if ( Dcnt&gt;2 ) return !puts(&quot;-1&quot;);
	if ( !Dcnt )
	{
		for ( int i=1;i&lt;(int)B.size();i++ ) Ans.push_back(std::make_pair(B[i-1],B[i]));
		Point pos=(Point){0,0,0,-1};
		B.push_back(B[0]);
		for ( auto p:G ) if ( p.c!=B[0].c ) { pos=p;break; }
		for ( int i=1;i&lt;(int)B.size();i++ )
		{
			std::vector&lt;Point&gt; Points;
			for ( auto p:G ) if ( Inside(p,B[i-1],B[i],pos) ) Points.push_back(p);
			solve(Points,pos,B[i-1],B[i]);
		}
	}
	else
	{
		std::vector&lt;int&gt; D;
		std::vector&lt;Point&gt; L,R;
		for ( int i=1;i&lt;(int)B.size();i++ ) if ( B[i].c!=B[i-1].c ) D.push_back(i);
		if ( B[0].c!=B[(int)B.size()-1].c ) D.push_back((int)B.size());
		for ( int i=D[0];i&lt;D[1];i++ ) L.push_back(B[i]);
		for ( int i=D[1];i&lt;(int)B.size();i++ ) R.push_back(B[i]);
		for ( int i=0;i&lt;D[0];i++ ) R.push_back(B[i]);
		for ( int i=1;i&lt;(int)L.size();i++ )
		{
			Ans.push_back(std::make_pair(L[i-1],L[i]));
			std::vector&lt;Point&gt; Points;
			for ( auto p:G ) if ( Inside(p,L[i-1],L[i],R[0]) ) Points.push_back(p);
			solve(Points,R[0],L[i-1],L[i]);
		}
		for ( int i=1;i&lt;(int)R.size();i++ )
		{
			Ans.push_back(std::make_pair(R[i-1],R[i]));
			std::vector&lt;Point&gt; Points;
			for ( auto p:G ) if ( Inside(p,R[i-1],R[i],L[0]) ) Points.push_back(p);
			solve(Points,L[0],R[i-1],R[i]);
		}
	}
	std::sort(Ans.begin(),Ans.end(),[&amp;](const std::pair&lt;Point,Point&gt; &amp;u,const std::pair&lt;Point,Point&gt; &amp;v){return u.first.c&lt;v.first.c;});
	for ( auto p:Ans ) printf(&quot;%d %d\n&quot;,p.first.id,p.second.id);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 省选模拟测试 Round #11 solution (20/02/15)（C题坑待填）]]></title>
        <id>https://rensheyu.github.io/contest-221/</id>
        <link href="https://rensheyu.github.io/contest-221/">
        </link>
        <updated>2020-02-26T11:59:18.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://59.61.75.5:8018/contest/221">【比赛链接】</a></p>
<h2 id="a-怪兽">A. 怪兽</h2>
<p>【题解】</p>
<p>首先显然有回合越少越优. 二分求出最少需要的回合.</p>
<p>分类讨论：</p>
<p>①先杀 A 后杀 B：</p>
<p>二分杀 A 需要的回合，若剩下的杀不了 B 则将 A 中多余的一回合删去. 可以证明，A 中一定可以删去一回合使得刚好杀掉 A.</p>
<p>②先杀 B 后杀 A：</p>
<p>最优显然构造 AAABBBAAA 的情况.</p>
<p>逐位贪心，考虑后面能否杀完即可. 优先选 A. 具体细节参见代码.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
inline int read ( void )
{
	int x=0;char ch;
	while ( !isdigit(ch=getchar()) ) ;
	for ( x=ch^48;isdigit(ch=getchar()); ) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
	return x;
}
const int maxn=100000+10;
long long sum[maxn];
char ans[3][maxn];
inline void Print ( int k,int T,long long res )
{
	printf(&quot;%lld &quot;,res);
	for ( int i=1;i&lt;=T;i++ ) putchar(ans[k][i]);
	puts(&quot;&quot;);
}
signed main()
{
	for ( int i=1;i&lt;=100003;i++ ) sum[i]=sum[i-1]+i;
	for ( int Cases=read();Cases--; )
	{
		long long ha=read(),hb=read(),atka=read(),atkb=read();
		long long T=std::lower_bound(sum+1,sum+100004,ha+hb)-sum;
		
		long long A=std::lower_bound(sum+1,sum+100004,ha)-sum;
		long long vala=A*atka+T*atkb;
		for ( long long i=1;i&lt;=A;i++ ) ans[1][i]='A';
		for ( long long i=A+1;i&lt;=T;i++ ) ans[1][i]='B';
		if ( sum[T]-sum[A]&lt;hb ) ans[1][sum[A]-ha]='B';
		
		long long B=std::lower_bound(sum+1,sum+100004,hb)-sum;
		long long p=std::upper_bound(sum+1,sum+100004,sum[B]-hb)-sum-1;
		long long valb=T*atka+B*atkb;
		for ( long long i=1;i&lt;=p;i++ ) ans[2][i]='A';
		for ( long long i=p+1;i&lt;=B;i++ ) ans[2][i]='B';
		for ( long long i=B+1;i&lt;=T;i++ ) ans[2][i]='A';
		if ( sum[T]-sum[B]+sum[p]&lt;ha )
		{
			long long res=ha-sum[T]+sum[B];
			for ( long long i=1;i&lt;=B;i++ )
				if ( res&gt;2*i or res==i ) res-=i,ans[2][i]='A';
				else ans[2][i]='B';
		}
		
		if ( vala&lt;valb ) Print(1,T,vala);
		else if ( vala&gt;valb ) Print(2,T,valb);
		else
		{
			int f=1;
			for ( int i=1;i&lt;=T;i++ )
				if ( ans[1][i]&lt;ans[2][i] ) break;
				else if ( ans[1][i]&gt;ans[2][i] ) { f=2;break; }
			Print(f,T,vala);
		}
	}
	return 0;
}
</code></pre>
<h2 id="b-区间">B. 区间</h2>
<p>【题解】</p>
<p>考虑转化为字符串求解. 考虑本质不同的子串，建出 SAM，则每个节点的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 大小即为这个节点的贡献.</p>
<p>用单调栈维护编号，extend 时二分查找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 大小对应的编号位置，计算即可.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
inline int read ( void )
{
	int x=0;char ch;
	while ( !isdigit(ch=getchar()) ) ;
	for ( x=ch^48;isdigit(ch=getchar()); ) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
	return x;
}
const int maxn=400000+10;
int size=1,root=1,last=1,val[maxn],len[maxn],fa[maxn],st[maxn],a[maxn],tp;
std::unordered_map&lt;int,int&gt; ch[maxn];long long sum[maxn],ans;
inline void extend ( int c )
{
	int np=++size,p=last;val[np]=1;len[np]=len[p]+1;last=np;
	while ( p and !ch[p].count(c) ) ch[p][c]=np,p=fa[p];
	if ( !p ) fa[np]=root;
	else
	{
		int q=ch[p][c];
		if ( len[q]==len[p]+1 ) fa[np]=q;
		else
		{
			int nq=++size;len[nq]=len[p]+1;fa[nq]=fa[q];
			fa[q]=fa[np]=nq;ch[nq]=ch[q];
			while ( p and ch[p][c]==q ) ch[p][c]=nq,p=fa[p];
		}
	}
	int L=len[np]-len[fa[np]];
	int pos=std::lower_bound(st+1,st+tp+1,L)-st;
	ans+=sum[pos-1]+1LL*a[st[pos]]*(L-st[pos-1]);
}
inline void C ( void )
{
	for ( int i=1;i&lt;=size;i++ ) ch[i].clear(),fa[i]=0;
	root=last=size=1;tp=0;ans=0;
}
signed main()
{
	for ( int T=read();T--;C() )
	{
		int n=read();
		for ( int i=1;i&lt;=n;i++ )
		{
			a[i]=read();
			while ( tp and a[st[tp]]&lt;=a[i] ) tp--;
			st[++tp]=i;sum[tp]=sum[tp-1]+1LL*a[i]*(st[tp]-st[tp-1]);
			extend(a[i]);
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 省选模拟测试 Round #12 solution (20/02/18)]]></title>
        <id>https://rensheyu.github.io/contest-222/</id>
        <link href="https://rensheyu.github.io/contest-222/">
        </link>
        <updated>2020-02-26T11:56:34.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://59.61.75.5:8018/contest/222">【比赛链接】</a></p>
<h2 id="a-问题求解">A. 问题求解</h2>
<p>【题解】</p>
<p>类欧几里得板子题.</p>
<p>考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 二进制下每一位的贡献，有经典公式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">im</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span> 的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 位为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mfrac><mrow><mi>i</mi><mi>m</mi></mrow><msup><mn>2</mn><mi>x</mi></msup></mfrac><mo>⌋</mo><mo>−</mo><mn>2</mn><mo>⌊</mo><mfrac><mrow><mi>i</mi><mi>m</mi></mrow><msup><mn>2</mn><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow></msup></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor\frac{im}{2^x}\rfloor-2\lfloor\frac{im}{2^{x+1}}\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.200664em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.200664em;vertical-align:-0.345em;"></span><span class="mord">2</span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>. 类欧几里得即可.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int mod=1000000007;
long long n,m,ans[50],Ans;
inline long long LikeGcd ( long long a,long long b,long long c,long long n )
{
	long long nx=n%mod,v=b/c%mod*(nx+1)%mod;
	if ( !a ) return v;
	if ( a&gt;=c ) return (LikeGcd(a%c,b%c,c,n)+v+nx*(nx+1)/2%mod*((a/c)%mod))%mod;
	long long T=((__int128)a*n+b)/c-1;
	return ((T+1)%mod*nx%mod-LikeGcd(c,c-b-1,a,T)+mod)%mod;
}
signed main()
{
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	for ( long long w=0;(1LL&lt;&lt;w)&lt;=(m&lt;&lt;1);w++ ) ans[w]=LikeGcd(m,0,1LL&lt;&lt;w,n);
	for ( long long w=0;(1LL&lt;&lt;w)&lt;=m;w++ ) if ( (m&gt;&gt;w)&amp;1 ) Ans=(Ans+(ans[w]-2*ans[w+1]%mod+mod)%mod*((1LL&lt;&lt;w)%mod))%mod;
	return !printf(&quot;%lld\n&quot;,Ans);
}
</code></pre>
<h2 id="b-子串">B. 子串</h2>
<p>【题解】</p>
<p>考虑 hash 判断. 设第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 位的字母的后一个位置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>x</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">nxt_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，权值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>x</mi><msub><mi>t</mi><mi>i</mi></msub><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">nxt_i-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，即可 hash.</p>
<p>用可持久化线段树维护 hash 然后直接将所有后缀排序即可. 则答案为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>l</mi><mi>c</mi><mi>p</mi><mo>(</mo><msub><mi>s</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}-\sum\limits_{i=1}^{n-1} lcp(s_i,s_{i+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.478782em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5011130000000001em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mo>∑</mo><mi>n</mi><msup><mi>log</mi><mo>⁡</mo><mn>3</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\sum n \log^3 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148458em;vertical-align:-0.25001em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>. <s>如果常数非常优秀能过（注意不同二分方式造成的巨大常数差）. 卡卡常就过了.</s></p>
<p><s>考虑优化，用可持久化块状数组维护即可. 效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mo>∑</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\sum n \log n \sqrt n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0502900000000002em;vertical-align:-0.25001em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</s></p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
inline int read ( void )
{
	int x=0;char ch;
	while ( !isdigit(ch=getchar()) ) ;
	for ( x=ch^48;isdigit(ch=getchar()); ) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
	return x;
}
#define maxn 50010
#define Hash 1000000007
#define HASH unsigned long long
struct tree { int ls,rs;HASH val; } t[maxn*30];
int n,a[maxn],root[maxn],p[maxn],nxt[maxn],tot;
HASH Pow[maxn];std::set&lt;int&gt; s[maxn];
inline void modify ( int &amp;k,int fr,int l,int r,int p,HASH w )
{
	t[k=++tot]=t[fr];t[k].val+=w; 
	if ( l==r ) return;int mid=(l+r)&gt;&gt;1;
	if ( p&lt;=mid ) modify(t[k].ls,t[fr].ls,l,mid,p,w);
	else modify(t[k].rs,t[fr].rs,mid+1,r,p,w);
}
inline HASH query ( int k,int l,int r,int ql,int qr )
{
	if ( !k or ( ql&lt;=l and r&lt;=qr ) ) return t[k].val;
	HASH res=0;int mid=(l+r)&gt;&gt;1;
	if ( ql&lt;=mid and t[k].ls ) res+=query(t[k].ls,l,mid,ql,qr);
	if ( qr&gt;mid and t[k].rs ) res+=query(t[k].rs,mid+1,r,ql,qr);
	return res;
}
std::unordered_map&lt;int,HASH&gt; map[maxn];
inline HASH Q ( int l,int len )
{
	if ( map[l].count(len) ) return map[l][len];
	return map[l][len]=query(root[l],1,n,l,l+len-1)*Pow[l];
}
inline int lcp ( int x,int y )
{
	int l=0,r=n,ans=0,max=n-std::max(x,y)+1;
	while ( l&lt;=r )
	{
		int mid=(l+r)&gt;&gt;1;
		if ( mid&gt;max ) { r=mid-1;continue; }
		if ( Q(x,mid)==Q(y,mid) ) l=mid+1,ans=mid;
		else r=mid-1;
	}
	return ans;
}
int tmp[maxn];
inline bool cmp ( int x,int y )
{
	int l=lcp(x,y);
	if ( x+l&gt;n ) return true;
	if ( y+l&gt;n ) return false;
	return (*s[a[x+l]].lower_bound(x))-x&lt;(*s[a[y+l]].lower_bound(y))-y;
}
inline void solve_sort ( int l,int r )
{
	if ( l==r ) return;
	int mid=(l+r)&gt;&gt;1;
	solve_sort(l,mid);solve_sort(mid+1,r);
	int pos=l-1;
	for ( int pos1=l,pos2=mid+1;pos&lt;r; )
		if ( pos2==r+1 ) tmp[++pos]=p[pos1],pos1++;
		else if ( pos1==mid+1 ) tmp[++pos]=p[pos2],pos2++;
		else if ( !cmp(p[pos2],p[pos1]) ) tmp[++pos]=p[pos1],pos1++;
		else tmp[++pos]=p[pos2],pos2++;
	for ( int i=l;i&lt;=r;i++ ) p[i]=tmp[i];
}
signed main()
{
	Pow[0]=1;
	for ( int i=1;i&lt;=50000;i++ ) Pow[i]=Pow[i-1]*Hash;
	while ( ~scanf(&quot;%d&quot;,&amp;n) )
	{
		tot=root[n+1]=0;
		for ( int i=1;i&lt;=n;i++ ) s[a[i]=read()].insert(i),p[i]=i;
		for ( int i=n;i;nxt[a[i]]=i,i-- )
			if ( nxt[a[i]] ) modify(root[i],root[i+1],1,n,nxt[a[i]],(nxt[a[i]]-i)*Pow[n-i+1]);
			else root[i]=root[i+1];
		solve_sort(1,n);
		long long ans=1LL*n*(n+1)/2;
		for ( int i=1;i&lt;n;i++ ) ans-=lcp(p[i],p[i+1]);
		printf(&quot;%lld\n&quot;,ans);
		for ( int i=1;i&lt;=n;i++ ) map[i].clear(),s[i].clear(),nxt[i]=0;
	}
	return 0;
}
</code></pre>
<h2 id="c-内凸包">C. 内凸包</h2>
<p>【题解】</p>
<p>显然枚举顶点. 这里枚举内凸包的左下角 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>. 考虑 dp. 设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示最后一条边为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的答案. 考虑转移：</p>
<p>当且仅当前一条边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(j,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 围成为凸的且新增加的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">△</mi><mi>P</mi><mi>I</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">\triangle PIJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">△</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span> 里面没有点时可以转移.</p>
<p>显然转移的条件可以用三角前缀和的方式优化（三角形面积），注意处理细节. 即可做到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 判断. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">i,j,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 转移即可.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>T</mi><msup><mi>n</mi><mn>4</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(Tn^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. 注意写的常数即可通过.</p>
<p>观察转移的性质，显然转移是连续的（画图可以发现），因此可以倒序枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，同时往前跳，效率优化至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
inline int read ( void )
{
	int x=0;char ch;bool f=true;
	while ( !isdigit(ch=getchar()) ) if ( ch=='-' ) f=false;
	for ( x=ch^48;isdigit(ch=getchar()); ) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
	return f ? x : -x ;
}
struct Vector
{
	int x,y,id;double k;
	Vector(int _x=0,int _y=0){x=_x;y=_y;}
	inline friend Vector operator - ( const Vector &amp;u,const Vector &amp;v ) { return Vector(u.x-v.x,u.y-v.y); }
	inline friend int operator * ( const Vector &amp;u,const Vector &amp;v ) { return u.x*v.y-u.y*v.x; }
	inline int length ( void ) { return x*x+y*y; }
} p[60],q[60],P;
signed main()
{
	for ( int T=read();T--; )
	{
		int n=read(),ans=0;
		for ( int i=1;i&lt;=n;i++ ) p[i].x=read(),p[i].y=read();
		std::sort(p+1,p+n+1,[](const Vector &amp;u,const Vector &amp;v){return u.y==v.y ? u.x&lt;v.x : u.y&lt;v.y;});
		for ( int st=1;st&lt;=n;st++ )
		{
			int m=0;P=p[st];
			for ( int i=st+1;i&lt;=n;i++ ) q[++m]=p[i];
			std::sort(q+1,q+m+1,[&amp;](const Vector &amp;u,const Vector &amp;v){return (u-P)*(v-P)==0 ? (u-P).length()&lt;(v-P).length() : (u-P)*(v-P)&gt;0 ;});
			int f[60][60]={0};
			for ( int i=1;i&lt;=m;i++ )
			{
				int j=i-1;
				while ( j and (q[i]-P)*(q[j]-P)==0 ) j--;
				bool flag=(j==i-1);
				while ( j )
				{
					int k=j-1;
					while ( k and (q[i]-q[j])*(q[k]-q[j])&lt;0 ) k--;
					int s=abs((q[i]-P)*(q[j]-P));
					if ( k ) s+=f[j][k];
					if ( flag ) f[i][j]=s;
					ans=std::max(ans,s);j=k;
				}
				if ( flag ) for ( int j=2;j&lt;=i;j++ ) f[i][j]=std::max(f[i][j],f[i][j-1]);
			}
		}
		printf(&quot;%.1lf\n&quot;,ans*0.5);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 省选模拟测试 Round #13 solution (20/02/20)]]></title>
        <id>https://rensheyu.github.io/contest-223/</id>
        <link href="https://rensheyu.github.io/contest-223/">
        </link>
        <updated>2020-02-26T11:51:40.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://59.61.75.5:8018/contest/223">【比赛链接】</a></p>
<h2 id="a-欧拉路径树">A. 欧拉路径树</h2>
<p>【题解】</p>
<p>下面使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>. 考虑 dfs 依次处理每个子树.</p>
<p>显然对于每一种数字，相邻两个同种数字间的即为该节点的一个子树. 递归处理.</p>
<p>现在考虑一种情况：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn><mo>…</mo><mn>2001</mn></mrow><annotation encoding="application/x-tex">1 2 \dots 2 0 0 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span>. 假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 还没出现过，则有两种填法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn><mo>…</mo><mn>2131</mn></mrow><annotation encoding="application/x-tex">1 2 \dots 2 1 3 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn><mo>…</mo><mn>2321</mn></mrow><annotation encoding="application/x-tex">1 2 \dots 2 3 2 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">3</span><span class="mord">2</span><span class="mord">1</span></span></span></span>.</p>
<p>注意到这两种填法分别对应的树的形态为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 子节点及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 子节点. 画图分析知，这两种情况对其它任意节点没有区别.</p>
<p>因此我们考虑贪心，尽可能地多填当前的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>. 即使每棵子树尽量小，子树个数尽量多.</p>
<p>显然先递归处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>…</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \dots 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span> 这棵子树，递归回来后可压缩成单个节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>.</p>
<p>现在考虑处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12001</mn></mrow><annotation encoding="application/x-tex">1 2 0 0 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span> 类型的问题. 根据树的性质，应该用一个栈来维护.</p>
<p>若碰到一个非 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的数，且当前数出现过（可能是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 造成的），则判断与栈顶的下一个数是否相等，相等即可将栈顶弹出，否则入栈.</p>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，存在一种情况使得必须填后面出现过的数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10321</mn></mrow><annotation encoding="application/x-tex">1 0 3 2 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">3</span><span class="mord">2</span><span class="mord">1</span></span></span></span>. 这时候必须填 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>. 分析可得：当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub><mo>)</mo><mo>=</mo><mi>j</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">2(sum_{j-1}-sum_{i})=j-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 奇偶性相同时，可以填入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>.</p>
<p>上述式子可转化为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub><mo>−</mo><mi>i</mi><mo>=</mo><mn>2</mn><mi>s</mi><mi>u</mi><mi>m</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow><mo>−</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">2 sum_{i}-i=2sum{j-1}-j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>. 用数据结构（<s>splay 套 splay</s> map 套 set）分奇偶性维护即可.</p>
<p>因此对于每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 有：若能找到能填的位置就填入，并压栈；否则弹栈即可. 若栈空则选一个未使用过的数填入.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msup><mi>log</mi><mo>⁡</mo><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log^2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>（根据数据结构的使用而定，可能存在线性做法）. 期望得分：100.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
inline int read ( void )
{
	int x=0;char ch;bool f=true;
	while ( !isdigit(ch=getchar()) ) if ( ch=='-' ) f=false;
	for ( x=ch^48;isdigit(ch=getchar()); ) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
	return f ? x : -x ;
}
const int maxn=1000000+10;
int a[maxn],st[maxn],tp,n,sum[maxn],vis[maxn],times;
std::map&lt;int,std::set&lt;int&gt;&gt; s[2];
std::queue&lt;int&gt; unused;
std::vector&lt;int&gt; pos[maxn];
inline void solve ( int l,int r,int x )
{
	std::vector&lt;int&gt; G;
	for ( int i=l;i&lt;=r;i++ )
		if ( ~a[i] )
		{
			for ( int j=0;j&lt;(int)pos[a[i]].size()-1;j++ ) solve(pos[a[i]][j]+1,pos[a[i]][j+1]-1,a[i]);
			G.push_back(a[i]);i=pos[a[i]].back();
		}
		else G.push_back(-i);
	st[tp=1]=x;sum[0]=(G[0]&gt;0);s[0].clear();s[1].clear();++times;
	for ( int i=1;i&lt;(int)G.size();i++ )
		if ( G[i]&gt;0 ) sum[i]=sum[i-1]+1,s[i&amp;1][i-2*sum[i-1]].insert(i);
		else sum[i]=sum[i-1];
	for ( int i=0;i&lt;(int)G.size();i++ )
		if ( G[i]&gt;0 )
		{
			s[i&amp;1][i-2*sum[i-1]].erase(i);
			if ( tp&gt;1 and st[tp-1]==G[i] ) tp--;
			else st[++tp]=G[i];
		}
		else
		{
			if ( !s[i&amp;1][i-2*sum[i]].empty() )
			{
				int j=*s[i&amp;1][i-2*sum[i]].begin();
				a[-G[i]]=G[j];
				if ( vis[G[j]]==times ) while ( st[tp]!=G[j] ) tp--;
				else vis[G[j]]=times,st[++tp]=G[j];
			}
			else
			{
				if ( tp&gt;1 ) a[-G[i]]=st[--tp];
				else st[++tp]=a[-G[i]]=unused.front(),unused.pop();
			}
		}
}
signed main()
{
	for ( int T=read();T--; )
	{
		n=read();
		for ( int i=1;i&lt;(n&lt;&lt;1);i++ ) a[i]=read();
		a[1]=a[2*n-1]=1;
		for ( int i=1;i&lt;(n&lt;&lt;1);i++ ) if ( ~a[i] ) pos[a[i]].push_back(i);
		for ( int i=1;i&lt;=n;i++ ) if ( pos[i].empty() ) unused.push(i);
		for ( int i=0;i&lt;(int)pos[1].size()-1;i++ ) solve(pos[1][i]+1,pos[1][i+1]-1,1);
		for ( int i=1;i&lt;(n&lt;&lt;1);i++ ) printf(&quot;%d%c&quot;,a[i],&quot; \n&quot;[i==2*n-1]);
		for ( int i=1;i&lt;=n;i++ ) pos[i].clear();
	}
	return 0;
}
</code></pre>
<h2 id="b-匹配">B. 匹配</h2>
<p>【题解】</p>
<p>显然在 AC 自动机上用矩阵快速幂转移 dp. 记 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mo>∑</mo><mrow><mi mathvariant="normal">∣</mi><msub><mi>t</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow></mrow><annotation encoding="application/x-tex">t=\sum{|t_i|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> 为字符集，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>+</mo><mi>n</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi>n</mi><msup><mi>t</mi><mn>3</mn></msup><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>+</mo><mi>Q</mi><msup><mi>t</mi><mn>2</mn></msup><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log n+nt|\Sigma|+nt^3\log n+Qt^2\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>考虑优化倍增预处理部分：跳 lca 时，设当前在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，先跳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi mathvariant="normal">lowbit</mi><mo>⁡</mo><mo>(</mo><msub><mi mathvariant="normal">dep</mi><mo>⁡</mo><mi>x</mi></msub><mo>)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">2^{\operatorname{lowbit}(\operatorname{dep}_x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mord mathrm mtight">l</span><span class="mord mathrm mtight">o</span><span class="mord mathrm mtight" style="margin-right:0.01389em;">w</span><span class="mord mathrm mtight">b</span><span class="mord mathrm mtight">i</span><span class="mord mathrm mtight">t</span></span><span class="mopen mtight">(</span><span class="mop mtight"><span class="mop mtight"><span class="mord mathrm mtight">d</span><span class="mord mathrm mtight">e</span><span class="mord mathrm mtight">p</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.04167428571428572em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，再跳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi mathvariant="normal">lowbit</mi><mo>⁡</mo><mo>(</mo><msub><mi mathvariant="normal">dep</mi><mo>⁡</mo><mi>y</mi></msub><mo>)</mo></mrow></msup><mo>⋯</mo></mrow><annotation encoding="application/x-tex">2^{\operatorname{lowbit}(\operatorname{dep}_y)}\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.916078em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.916078em;"><span style="top:-3.0910780000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mord mathrm mtight">l</span><span class="mord mathrm mtight">o</span><span class="mord mathrm mtight" style="margin-right:0.01389em;">w</span><span class="mord mathrm mtight">b</span><span class="mord mathrm mtight">i</span><span class="mord mathrm mtight">t</span></span><span class="mopen mtight">(</span><span class="mop mtight"><span class="mop mtight"><span class="mord mathrm mtight">d</span><span class="mord mathrm mtight">e</span><span class="mord mathrm mtight">p</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.04167428571428572em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.40475428571428573em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span></span></span></span>，这样只用处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">lowbit</mi><mo>⁡</mo><mo>(</mo><msub><mi mathvariant="normal">dep</mi><mo>⁡</mo><mi>x</mi></msub><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">i\in[0,\operatorname{lowbit}(\operatorname{dep}_x)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="mord mathrm">b</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mop"><span class="mop"><span class="mord mathrm">d</span><span class="mord mathrm">e</span><span class="mord mathrm">p</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.057252em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">]</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span> 矩阵.</p>
<p>但这样还是容易被卡（如构造很多点深度都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1024</mn></mrow><annotation encoding="application/x-tex">1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span></span> 的树），所以可以考虑在根节点上加若干点来避免这种问题. 从最低点开始考虑，如果深度为偶数的点多于奇数，可以在根上加一个点，从而保证深度为奇数的点不少于深度为偶数的，同理去考虑其它二进制位. 可知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>t</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(t^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 次乘法的次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>×</mo><mn>1</mn><mo>+</mo><mfrac><mi>n</mi><mn>4</mn></mfrac><mo>×</mo><mn>2</mn><mo>+</mo><mo>⋯</mo><mo>&lt;</mo><mn>2</mn><mi>n</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\frac{n}{2}\times 1+\frac{n}{4}\times 2+\cdots&lt;2n=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>. 所以总时间复杂度降到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>+</mo><mi>n</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi>n</mi><msup><mi>t</mi><mn>3</mn></msup><mo>+</mo><mi>Q</mi><msup><mi>t</mi><mn>2</mn></msup><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log n + nt|\Sigma|+nt^3+Qt^2\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mord">Σ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int mod=998244353;
int size,ch[50][30],fail[50],Log[5000],Low[5000],cnt[5000];
int anc[5000][20],n,m,Q,dep[5000],h[5000],e_cnt,root=1,k,add;
bool flag[50];
struct edge { int v,nxt,w; } e[10000];
struct matrix
{
	int a[50][50];
	inline int * operator [] ( const int x ) { return a[x]; }
	matrix(){memset(a,0,sizeof(a));}
	inline friend matrix operator * ( matrix A,matrix B )
	{
		matrix C;
		for ( int i=0;i&lt;=size;i++ ) for ( int k=0;k&lt;=size;k++ ) for ( int j=0;j&lt;=size;j++ ) C[i][j]=(C[i][j]+1LL*A[i][k]*B[k][j])%mod;
		return C;
	}
};
std::vector&lt;matrix&gt; U[3000],D[3000];
inline matrix make_matrix ( int trans )
{
	std::vector&lt;int&gt; tr;matrix T;
	for ( int i=1;i&lt;=26;i++ ) if ( trans&amp;(1&lt;&lt;i) ) tr.push_back(i);
	for ( int i=0;i&lt;=size;i++ ) for ( int j:tr ) T[i][ch[i][j]]++;
	return T;
}
inline void dfs ( int u,int fr,int trans )
{
	dep[u]=dep[anc[u][0]=fr]+1;
	U[u].push_back(make_matrix(trans));
	D[u].push_back(make_matrix(trans));
	for ( int i=1;anc[u][i-1];i++ ) anc[u][i]=anc[anc[u][i-1]][i-1];
	for ( int i=1;i&lt;=Low[dep[u]];i++ )
		U[u].push_back(U[u][i-1]*U[anc[u][i-1]][i-1]),
		D[u].push_back(D[anc[u][i-1]][i-1]*D[u][i-1]);
	for ( int i=h[u];i;i=e[i].nxt ) if ( e[i].v!=fr ) dfs(e[i].v,u,e[i].w);
}
inline int lca ( int u,int v )
{
	if ( dep[u]&lt;dep[v] ) std::swap(u,v);
	for ( int i=Log[dep[u]];~i;i-- ) if ( dep[anc[u][i]]&gt;=dep[v] ) u=anc[u][i];
	if ( u==v ) return u;
	for ( int i=Log[dep[u]];~i;i-- ) if ( anc[u][i]!=anc[v][i] ) u=anc[u][i],v=anc[v][i];
	return anc[u][0];
}
inline void addedge ( int u,int v,int w )
{
	e[++e_cnt].nxt=h[u];e[h[u]=e_cnt].v=v;e[e_cnt].w=w;
	e[++e_cnt].nxt=h[v];e[h[v]=e_cnt].v=u;e[e_cnt].w=w;
}
signed main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	for ( int i=2;i&lt;=n;i++ )
	{
		int u,v,val=0;char s[30]={'\0'};
		scanf(&quot;%d%d %s&quot;,&amp;u,&amp;v,s+1);
		for ( int i=1;s[i];i++ ) val|=1&lt;&lt;(s[i]^96);
		addedge(u,v,val);
	}
	std::queue&lt;int&gt; q;q.push(1);
	while ( !q.empty() )
	{
		int u=q.front();q.pop();
		for ( int i=h[u];i;i=e[i].nxt ) if ( e[i].v!=anc[u][0] ) dep[e[i].v]=dep[anc[e[i].v][0]=u]+1,q.push(e[i].v);
	}
	for ( int i=1;i&lt;=n;i++ ) cnt[dep[i]]++,k=std::max(k,dep[i]);
	for ( int S=0;(1&lt;&lt;S)&lt;=k and S&lt;=9;S++ )
	{
		int tot[2]={0},U=(1&lt;&lt;S)-1;
		for ( int i=0;i&lt;=k;i++ ) if ( (i&amp;U)==add ) tot[((i+add)&gt;&gt;S)&amp;1]+=cnt[i];
		if ( tot[0]&gt;tot[1] ) add+=1&lt;&lt;S;
	}
	if ( add )
	{
		root=n+add;
		for ( int i=add;i&gt;1;i-- ) addedge(n+i,n+i-1,0);
		addedge(n+1,1,0);
	}
	n+=add;
	for ( int i=2;i&lt;=n;i++ ) Log[i]=Log[i&gt;&gt;1]+1,Low[i]=Log[i&amp;(-i)];
	for ( int i=1;i&lt;=m;i++ )
	{
		char s[50]={'\0'};scanf(&quot; %s&quot;,s+1);
		int u=0;
		for ( int i=1;s[i];i++ )
		{
			if ( !ch[u][s[i]^96] ) ch[u][s[i]^96]=++size;
			u=ch[u][s[i]^96];
		}
		flag[u]=true;
	}
	for ( int i=1;i&lt;=26;i++ ) if ( ch[0][i] ) q.push(ch[0][i]);
	while ( !q.empty() )
	{
		int u=q.front();q.pop();
		for ( int i=1;i&lt;=26;i++ )
			if ( ch[u][i] ) fail[ch[u][i]]=ch[fail[u]][i],flag[ch[u][i]]|=flag[fail[ch[u][i]]],q.push(ch[u][i]);
			else ch[u][i]=ch[fail[u]][i];
	}
	for ( int i=0;i&lt;=size;i++ ) if ( flag[i] ) for ( int j=1;j&lt;=26;j++ ) ch[i][j]=i;
	dep[0]=-1;dfs(root,0,0);
	while ( Q-- )
	{
		int u,v,ans=0,f[50]={0},g[50]={0};scanf(&quot;%d%d&quot;,&amp;u,&amp;v);int l=lca(u,v);
		std::vector&lt;matrix&gt; tru,trv;
		for ( int x=u,k;x!=l;x=anc[x][k] ) k=std::min(Low[dep[x]],Log[dep[x]-dep[l]-1]),tru.push_back(U[x][k]);
		for ( int x=v,k;x!=l;x=anc[x][k] ) k=std::min(Low[dep[x]],Log[dep[x]-dep[l]-1]),trv.push_back(D[x][k]);
		std::reverse(trv.begin(),trv.end());f[0]=1;
		for ( auto A:tru )
		{
			for ( int i=0;i&lt;=size;i++ ) g[i]=0;
			for ( int k=0;k&lt;=size;k++ ) for ( int j=0;j&lt;=size;j++ ) g[j]=(g[j]+1LL*f[k]*A[k][j])%mod;
			for ( int i=0;i&lt;=size;i++ ) f[i]=g[i];
		}
		for ( auto A:trv )
		{
			for ( int i=0;i&lt;=size;i++ ) g[i]=0;
			for ( int k=0;k&lt;=size;k++ ) for ( int j=0;j&lt;=size;j++ ) g[j]=(g[j]+1LL*f[k]*A[k][j])%mod;
			for ( int i=0;i&lt;=size;i++ ) f[i]=g[i];
		}
		for ( int i=0;i&lt;=size;i++ ) if ( flag[i] ) ans=(ans+f[i])%mod;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<h2 id="c-旅行">C. 旅行</h2>
<p>【题解】</p>
<p>最近的测试越来越有 FJOI 的风格了……</p>
<p>考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 非常小，可用类似折半搜索的做法.</p>
<p>强行令环拆成两半，一半染成黑色，另一半染成白色. 对黑白色分别求解最长链再处理即可.</p>
<p>考虑怎么对所有点染色. 可以采用随机化的方法. 因此考虑随机 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 次进行求解.</p>
<p>对于染色完后的处理，最大只需要处理到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">l=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 为链上点数）的情况，则有：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">l=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，枚举每条边.</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">l=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，枚举两条边判断是否有公共点，有就更新.</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">l=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，先预处理所有边两点间的距离，然后考虑枚举两条边，若两条边无共点则用其中各一个节点间的预处理距离加上两边边权即可.</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">l=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>，考虑边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u,v),(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>. 若有贡献显然为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>p</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u,v,p,x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 型贡献，则对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo separator="true">,</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">v,x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span></span></span></span> 需要算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个点的最长链. 注意不可重复，因此需要维护前三长链.</p>
<p>第一轮枚举两条边处理前三长链，第二轮枚举两条边算答案即可.</p>
<p>最后算答案枚举两条跨色边算答案. 效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>T</mi><msup><mi>m</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(Tm^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">T=1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 时答案出错概率非常小（<s>错了再交一次就行</s>），且复杂度优秀.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const long long inf=1LL&lt;&lt;60;
int n,m,k,u[400],v[400],c[400],pos[400][400][3];
long long w[400],dis[400][400],Dis[2][400][400]; 
inline void solve2 ( int color )
{
	for ( int i=1;i&lt;=m;i++ ) if ( c[u[i]]==color and c[v[i]]==color ) Dis[color][u[i]][v[i]]=Dis[color][v[i]][u[i]]=w[i];
}
inline void solve3 ( int color )
{
	for ( int i=1;i&lt;=m;i++ ) if ( c[u[i]]==color and c[v[i]]==color )
		for ( int j=1;j&lt;=m;j++ ) if ( c[u[j]]==color and c[v[j]]==color ) if ( i!=j )
		{
			if ( u[i]==u[j] ) Dis[color][v[i]][v[j]]=std::max(Dis[color][v[i]][v[j]],w[i]+w[j]);
	else	if ( u[i]==v[j] ) Dis[color][v[i]][u[j]]=std::max(Dis[color][v[i]][u[j]],w[i]+w[j]);
	else	if ( v[i]==u[j] ) Dis[color][u[i]][v[j]]=std::max(Dis[color][u[i]][v[j]],w[i]+w[j]);
	else	if ( v[i]==v[j] ) Dis[color][u[i]][u[j]]=std::max(Dis[color][u[i]][u[j]],w[i]+w[j]);
		}
}
inline void solve4 ( int color )
{
	for ( int i=1;i&lt;=m;i++ ) if ( c[u[i]]==color and c[v[i]]==color )
		for ( int j=1;j&lt;=m;j++ ) if ( c[u[j]]==color and c[v[j]]==color )
			if ( i!=j ) if ( u[i]!=u[j] and u[i]!=v[j] and v[i]!=u[j] and v[i]!=v[j] )
				Dis[color][u[i]][u[j]]=std::max(Dis[color][u[i]][u[j]],dis[v[i]][v[j]]+w[i]+w[j]),
				Dis[color][u[i]][v[j]]=std::max(Dis[color][u[i]][v[j]],dis[v[i]][u[j]]+w[i]+w[j]),
				Dis[color][v[i]][u[j]]=std::max(Dis[color][v[i]][u[j]],dis[u[i]][v[j]]+w[i]+w[j]),
				Dis[color][v[i]][v[j]]=std::max(Dis[color][v[i]][v[j]],dis[u[i]][u[j]]+w[i]+w[j]);
}
inline void solve5 ( int color )
{
	std::function &lt; void ( int,int,int ) &gt; Addedge = [&amp;] ( int x,int y,int z ) {
		int rnk=0;
		while ( rnk&lt;3 )
		{
			int u=pos[x][y][rnk];
			if ( dis[x][u]+dis[u][y]&lt;dis[x][z]+dis[z][y] ) break;
			rnk++;
		}
		if ( rnk&lt;3 )
		{
			for ( int i=2;i&gt;rnk;i-- ) pos[x][y][i]=pos[x][y][i-1];
			pos[x][y][rnk]=z;
		}
	};
	std::function &lt; void ( int,int,int,int ) &gt; work = [&amp;] ( int x,int y,int u,int v ) {
		int rnk = 0;
		while ( pos[u][v][rnk]==x or pos[u][v][rnk]==y ) rnk++;
		int z=pos[u][v][rnk];
		Dis[color][x][y]=std::max(Dis[color][x][y],dis[x][u]+dis[u][z]+dis[z][v]+dis[v][y]);
	};
	for ( int i=1;i&lt;=n;i++ ) if ( c[i]==color ) for ( int j=1;j&lt;=n;j++ ) if ( c[j]==color ) pos[i][j][0]=pos[i][j][1]=pos[i][j][2]=0;
	for ( int i=1;i&lt;=m;i++ ) if ( c[u[i]]==color and c[v[i]]==color )
		for ( int j=1;j&lt;=m;j++ ) if ( c[u[j]]==color and c[v[j]]==color ) if ( i!=j )
		{
			if ( u[i]==u[j] ) Addedge(v[i],v[j],u[i]);
	else	if ( u[i]==v[j] ) Addedge(v[i],u[j],u[i]);
	else	if ( v[i]==u[j] ) Addedge(u[i],v[j],v[i]);
	else	if ( v[i]==v[j] ) Addedge(u[i],u[j],v[i]);
		}
	for ( int i=1;i&lt;=m;i++ ) if ( c[u[i]]==color and c[v[i]]==color )
		for ( int j=1;j&lt;=m;j++ ) if ( c[u[j]]==color and c[v[j]]==color )
			if ( i!=j ) if ( u[i]!=u[j] and u[i]!=v[j] and v[i]!=u[j] and v[i]!=v[j] )
				work(u[i],u[j],v[i],v[j]),work(u[i],v[j],v[i],u[j]),work(v[i],u[j],u[i],v[j]),work(v[i],v[j],u[i],u[j]);
}
signed main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	for ( int i=0;i&lt;=n;i++ ) for ( int j=0;j&lt;=n;j++ ) dis[i][j]=-inf;
	for ( int i=1;i&lt;=m;i++ ) scanf(&quot;%d%d%lld&quot;,&amp;u[i],&amp;v[i],&amp;w[i]),dis[u[i]][v[i]]=dis[v[i]][u[i]]=w[i];
	if ( k==3 )
	{
		long long ans=-1;
		for ( int i=1;i&lt;=n-2;i++ ) for ( int j=i+1;j&lt;=n-1;j++ ) for ( int k=j+1;k&lt;=n;k++ ) ans=std::max(ans,dis[i][j]+dis[j][k]+dis[k][i]);
		if ( ~ans ) printf(&quot;%lld\n&quot;,ans);
		else puts(&quot;impossible&quot;);
		return 0;
	}
	srand(time(NULL));long long ans=-1;
	for ( int Rnd=1;Rnd&lt;=1000;Rnd++ )
	{
		for ( int i=1;i&lt;=n;i++ ) c[i]=rand()&amp;1;
		for ( int i=1;i&lt;=n;i++ ) for ( int j=1;j&lt;=n;j++ ) Dis[0][i][j]=Dis[1][i][j]=-inf;
		for ( int i=1;i&lt;=m;i++ ) if ( c[u[i]] and !c[v[i]] ) std::swap(u[i],v[i]);
		if ( k==4 ) solve2(0),solve2(1);
		else if ( k==5 ) solve2(0),solve3(1);
		else if ( k==6 ) solve3(0),solve3(1);
		else if ( k==7 ) solve3(0),solve4(1);
		else if ( k==8 ) solve4(0),solve4(1);
		else if ( k==9 ) solve4(0),solve5(1);
		else if ( k==10 ) solve5(0),solve5(1);
		for ( int i=1;i&lt;=m;i++ ) if ( c[u[i]]^c[v[i]] ) for ( int j=1;j&lt;=m;j++ ) if ( c[u[j]]^c[v[j]] )
			if ( i!=j ) ans=std::max(ans,Dis[0][u[i]][u[j]]+Dis[1][v[i]][v[j]]+w[i]+w[j]);
	}
	if ( ~ans ) printf(&quot;%lld\n&quot;,ans);
	else puts(&quot;impossible&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 省选模拟测试 Round #14 solution (20/02/22)]]></title>
        <id>https://rensheyu.github.io/contest-224/</id>
        <link href="https://rensheyu.github.io/contest-224/">
        </link>
        <updated>2020-02-26T11:45:21.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://59.61.75.5:8018/contest/224">【比赛链接】</a></p>
<h2 id="a-雕像">A. 雕像</h2>
<p>【题解】</p>
<p>一般最大最小问题可用二分解决，而和的最小值/最大值类问题可用 dp 凸优化（wqs 二分）解决.</p>
<p>外层使用 dp 凸优化，内层 dp 符合要求覆盖所有村庄需要的最少雕像个数，由于满足四边形不等式，单调队列+二分优化 dp 即可.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n \log \sum\limits_{i=1}^n a_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const long long inf=1LL&lt;&lt;60;
const int maxn=300000+10;
long long sum[maxn],f[maxn];
int a[maxn],g[maxn],q[maxn],pos[maxn],n,k;
inline long long query ( int l,int r ) { return sum[l-1]+sum[r]-sum[(l+r)/2]-sum[(l+r-1)/2]; }
inline void solve ( long long k )
{
	for ( int i=1;i&lt;=n;i++ ) f[i]=inf,g[i]=q[i]=pos[i]=0;
	int l=1,r=1;pos[1]=n;
	for ( int i=1;i&lt;=n;i++ )
	{
		while ( l&lt;r and pos[l]&lt;=i ) l++;
		f[i]=f[q[l]]+query(q[l]+1,i)+k;
		g[i]=g[q[l]]+1;
		while ( l&lt;r )
		{
			long long lst=f[q[r]]+query(q[r]+1,pos[r-1]);
			long long res=f[i]+query(i+1,pos[r-1]);
			if ( lst&lt;res or ( lst==res and g[q[r]]&lt;=g[i] ) ) break;
			r--;
		}
		int ll=q[r],rr=n+1;
		while ( ll&lt;rr )
		{
			int mid=(ll+rr)&gt;&gt;1;
			long long lst=f[q[r]]+query(q[r]+1,mid);
			long long res=f[i]+query(i+1,mid);
			if ( lst&gt;res or ( lst==res and g[q[r]]&gt;g[i] ) ) rr=mid;
			else ll=mid+1;
		}
		pos[r]=ll;q[++r]=i;
	}
}
signed main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	for ( int i=1;i&lt;=n;i++ ) scanf(&quot;%d&quot;,&amp;a[i]),sum[i]=sum[i-1]+a[i];
	long long l=0,r=sum[n];
	while ( l&lt;r )
	{
		long long mid=(l+r)&gt;&gt;1;
		solve(mid);
		if ( g[n]&gt;k ) l=mid+1;
		else r=mid;
	}
	solve(l);
	return !printf(&quot;%lld\n&quot;,f[n]-k*l);
}
</code></pre>
<h2 id="b-函数">B. 函数</h2>
<p>【题解】</p>
<p>显然 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><mi>d</mi><mo>)</mo><mo>=</mo><msub><mo>∏</mo><mrow><mi>p</mi><mtext> is prime</mtext></mrow></msub><mi>g</mi><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">H(d)=\prod\limits_{p\text{ is prime}} g(p,d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.8696200000000003em;vertical-align:-1.119615em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7500050000000001em;"><span style="top:-2.116493em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord text mtight"><span class="mord mtight"> is prime</span></span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∏</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.119615em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span> 是积性函数。由二平方和定理（<s>打表找规律</s>）可知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><msup><mi>p</mi><mi>e</mi></msup><mo>)</mo><mo>=</mo><mn>3</mn><mi>e</mi><mo>+</mo><mn>1</mn><mtext> </mtext><mo>(</mo><mi>p</mi><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mn>4</mn><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">H(p^e)=3e+1\,(p\equiv 1\pmod 4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，Min_25 筛即可.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
long long n,m,pr[100000],tot,Pow[100000],g[100000],S1[100000][5],S2[100000][5],sum1[100000],sum2[100000];
bool flag[100000];
inline long long f ( long long p,long long k ) { return (p%4==1) ? 3*k+1 : 1 ; }
inline long long Min_25 ( long long x,long long k )
{
	if ( x&lt;=1 or pr[k]&gt;x ) return 0;
	long long ans=((x&lt;=m)?sum1[x]:sum2[n/x])-Pow[k-1];
	for ( long long i=k;i&lt;=tot and pr[i]*pr[i]&lt;=x;i++ ) for ( long long v=pr[i],j=1;v*pr[i]&lt;=x;v*=pr[i],j++ ) ans+=Min_25(x/v,i+1)*f(pr[i],j)+f(pr[i],j+1);
	return ans;
}
signed main()
{
	long long T;
	for ( scanf(&quot;%lld&quot;,&amp;T);T--; )
	{
		scanf(&quot;%lld&quot;,&amp;n);m=(long long)sqrt(n);
		for ( long long i=1;i&lt;=m;i++ ) flag[i]=true;
		flag[1]=false;tot=0;
		for ( long long i=2;i&lt;=m;i++ )
		{
			if ( flag[i] ) pr[++tot]=i,Pow[tot]=Pow[tot-1]+((i%4==1)?4:1);
			for ( long long j=1;j&lt;=tot and pr[j]*i&lt;=m;j++ )
			{
				flag[i*pr[j]]=false;
				if ( !(i%pr[j]) ) break;
			}
		}
		for ( long long i=1;i&lt;=n;i=n/(n/(i+1)) )
		{
			if ( i&lt;=m ) for ( long long j=0;j&lt;4;j++ ) S1[i][j]=(i-1)/4+((i-1)%4&gt;=(j+3)%4);
			else for ( long long j=0;j&lt;4;j++ ) S2[n/i][j]=(i-1)/4+((i-1)%4&gt;=(j+3)%4);
			if ( i==n ) break;
		}
		for ( long long i=1;i&lt;=tot;i++ )
		{
			long long p=pr[i],p2=p*p;
			for ( long long a=n;a&gt;=p2;a=n/(n/a+1) ) for ( long long j=0;j&lt;4;j++ )
				if ( a&lt;=m )
				{
					if ( a/p&lt;=m ) S1[a][p*j%4]-=S1[a/p][j]-S1[p-1][j];
					else S1[a][p*j%4]-=S2[n/(a/p)][j]-S1[p-1][j];
				}
				else
				{
					if ( a/p&lt;=m ) S2[n/a][p*j%4]-=S1[a/p][j]-S1[p-1][j];
					else S2[n/a][p*j%4]-=S2[n/(a/p)][j]-S1[p-1][j];
				}
		}
		for ( long long i=1;i&lt;=n;i=n/(n/(i+1)) )
		{
			if ( i&lt;=m ) S1[i][1]--;
			else S2[n/i][1]--;
			if ( i==n ) break;
		}
		for ( long long i=1;i&lt;=n;i=n/(n/(i+1)) )
		{
			if ( i&lt;=m ) sum1[i]=4*S1[i][1]+S1[i][3]+1;
			else sum2[n/i]=4*S2[n/i][1]+S2[n/i][3]+1;
			if ( i==n ) break;
		}
		printf(&quot;%lld\n&quot;,Min_25(n,1)+1);
	}
	return 0;
}
</code></pre>
<h2 id="c-incomparable-pairs">C. Incomparable Pairs</h2>
<p>【题解】</p>
<p>考虑容斥，计算子串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 为子串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的子串数量.</p>
<p>对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 建 SAM，对于每一个一个本质不同的子串，计算它包含的本质不同的子串个数之和就是答案.</p>
<p>一个子串可能出现多次，任意选取一次就可以计算答案. 而对于自动机上的一个节点，它产生的贡献为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>min</mi><mo>⁡</mo><mo separator="true">,</mo><mi>r</mi></mrow></msub><mo separator="true">,</mo><msub><mi>s</mi><mrow><mi>min</mi><mo>⁡</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi></mrow></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>s</mi><mrow><mi>max</mi><mo>⁡</mo><mo separator="true">,</mo><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{\min,r},s_{\min+1,r},\dots,s_{\max,r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight">min</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight">min</span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight">max</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 中的本质不同的子串.</p>
<p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 开始，到现在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 的本质不同子串的个数（位置不同的相同子串只记录最后一次），可以对每一个本质不同的字串，在它最后一次出现的左端点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span>.</p>
<p>每插入一个字符，就算一次新增的自动机节点的贡献，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 变大的时候，在 parent 树上从新增节点到根的最后出现位置都会更改。相当于把 parent 树上这一条链染色. 用 LCT 维护.</p>
<p>发现我们要求的是后缀和后的区间和，可以在线段树上区间加等差数列.</p>
<p>发现 SAM 上节点可能分裂，这里查询答案的时候用原来的大小，查询这个节点原来的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>R</mi><mo>−</mo><mi>max</mi><mo>⁡</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>R</mi><mo>−</mo><mi>min</mi><mo>⁡</mo><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[R-\max+1,R-\min+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>. 累加就是答案.</p>
<p>效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msup><mi>log</mi><mo>⁡</mo><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log^2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int maxn=200000+10;
int n,pos[maxn],root,last,size,nxt[maxn][27],min[maxn],max[maxn],fa[maxn],ch[maxn][2],val[maxn];
char s[maxn];
struct tree { long long val,tag1,tag2; } t[maxn&lt;&lt;2];
#define ls (k&lt;&lt;1)
#define rs (k&lt;&lt;1|1)
#define mid ((l+r)&gt;&gt;1)
inline void modify1 ( int k,int len,long long w ) { t[k].val+=w*len;t[k].tag1+=w; }
inline void modify2 ( int k,int len,long long l,long long w ) { t[k].val+=l*len+1LL*len*(len+1)/2*w;t[k].tag1+=l;t[k].tag2+=w; }
inline void pushdown ( int k,int len )
{
   if ( t[k].tag1 ) modify1(ls,(len+1)&gt;&gt;1,t[k].tag1),modify1(rs,len&gt;&gt;1,t[k].tag1),t[k].tag1=0;
   if ( t[k].tag2 ) modify2(ls,(len+1)&gt;&gt;1,t[k].tag2*(len&gt;&gt;1),t[k].tag2),modify2(rs,len&gt;&gt;1,0,t[k].tag2),t[k].tag2=0;
}
inline void update1 ( int k,int l,int r,int ql,int qr,long long w )
{
   if ( ql&lt;=l and r&lt;=qr ) { modify1(k,r-l+1,w);return; }
   pushdown(k,r-l+1);
   if ( ql&lt;=mid ) update1(ls,l,mid,ql,qr,w);
   if ( qr&gt;mid ) update1(rs,mid+1,r,ql,qr,w);
   t[k].val=t[ls].val+t[rs].val;
}
inline void update2 ( int k,int l,int r,int ql,int qr,long long w )
{
   if ( ql&lt;=l and r&lt;=qr ) { modify2(k,r-l+1,(qr-r)*w,w);return; }
   pushdown(k,r-l+1);
   if ( ql&lt;=mid ) update2(ls,l,mid,ql,qr,w);
   if ( qr&gt;mid ) update2(rs,mid+1,r,ql,qr,w);
   t[k].val=t[ls].val+t[rs].val;
}
inline void change ( int l,int r,long long v )
{
   if ( l&gt;1 ) update1(1,1,n,1,l-1,(r-l+1)*v);
   if ( l&gt;0 and r&gt;0 and l&lt;=r ) update2(1,1,n,l,r,v);
}
inline long long query ( int k,int l,int r,int ql,int qr )
{
   if ( ql&lt;=l and r&lt;=qr ) return t[k].val;
   pushdown(k,r-l+1);long long res=0;
   if ( ql&lt;=mid ) res+=query(ls,l,mid,ql,qr);
   if ( qr&gt;mid ) res+=query(rs,mid+1,r,ql,qr);
   return res;
}
#undef ls
#undef rs
#undef mid
#define ls(x) ch[x][0]
#define rs(x) ch[x][1]
inline void pushdown ( int x ) { val[ls(x)]=val[rs(x)]=val[x]; }
inline int get ( int x,int k=1 ) { return ch[fa[x]][k]==x; }
inline bool nroot ( int x ) { return get(x,0) || get(x,1); }
inline void rotate ( int x )
{
   int y=fa[x],z=fa[y],k=get(x);
   if ( nroot(y) ) ch[z][get(y)]=x;
   fa[ch[y][k]=ch[x][!k]]=y,ch[x][!k]=y;
   fa[y]=x,fa[x]=z;
}
int st[maxn],tp;
inline void splay ( int x )
{
   st[tp=1]=x;
   for ( int y=x;nroot(y);st[++tp]=y=fa[y] ) ;
   for ( ;tp;tp-- ) pushdown(st[tp]);
   for ( ;nroot(x);rotate(x) ) if ( nroot(fa[x]) ) (get(x)^get(fa[x])) ? rotate(x) : rotate(fa[x]);
}
inline void access ( int x,int v )
{
   for ( int y=0;x; ) splay(x),rs(x)=y,change(val[x]-max[x]+1,val[x]-max[fa[x]],-1),y=x,x=fa[x];
   splay(1);val[1]=v;change(1,v,1);
}
unsigned long long num,ans;
inline int extend ( int c )
{
   int np=++size,p=last;max[np]=max[p]+1;last=np;
   while ( p and !nxt[p][c] ) nxt[p][c]=np,p=fa[p];
   if ( !p ) fa[np]=root;
   else
   {
   	int q=nxt[p][c];
   	if ( max[q]==max[p]+1 ) fa[np]=q;
   	else
   	{
   		int nq=++size;max[nq]=max[p]+1;fa[nq]=fa[q];
   		fa[q]=fa[np]=nq;memcpy(nxt[nq],nxt[q],sizeof(nxt[nq]));
   		while ( p and nxt[p][c]==q ) nxt[p][c]=nq,p=fa[p];
   	}
   }
   num+=max[np]-max[fa[np]];min[np]=max[fa[np]]+1;
   return np;
}
signed main()
{
   scanf(&quot; %s&quot;,s+1);n=strlen(s+1);root=last=++size;
   for ( int i=1;i&lt;=n;i++ ) pos[i]=extend(s[i]^96);
   for ( int i=1;i&lt;=n;i++ ) access(pos[i],i),ans+=query(1,1,n,i-max[pos[i]]+1,i-min[pos[i]]+1);
   if ( num&amp;1 ) num=(num+1)/2*num;
   else num=num/2*(num+1);
   return !printf(&quot;%llu\n&quot;,num-ans);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 寒假专题训练：计算几何 Part 3]]></title>
        <id>https://rensheyu.github.io/subject-geometry-3/</id>
        <link href="https://rensheyu.github.io/subject-geometry-3/">
        </link>
        <updated>2020-02-26T10:11:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="day-5">Day 5</h1>
<h2 id="一-自适应simpson积分法">一、自适应simpson积分法</h2>
<p>考虑这么一个问题：求任意曲线与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 轴，直线 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">x=l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，直线 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">x=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 包围的图形的面积.</p>
<p>曲边梯形的面积问题，通常用定积分可以解决. 但任意曲线就出现了一个问题：如何求解定积分？</p>
<p>显然对于任意函数，求解定积分不是那么容易，我们考虑用近似的方式解决问题.</p>
<p>假设当前处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 部分的曲边梯形面积. 由于是曲边梯形，考虑用二次函数近似.</p>
<p>设二次函数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>a</mi><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>x</mi><mo>+</mo><mi>c</mi><mo>(</mo><mi>x</mi><mo>∈</mo><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)=ax^2+bx+c(x \in [l,r])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>.</p>
<p>积分得：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mo>∫</mo><mi>l</mi><mi>r</mi></msubsup><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi>d</mi><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msubsup><mo>∫</mo><mi>l</mi><mi>r</mi></msubsup><mo>(</mo><mi>a</mi><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>x</mi><mo>+</mo><mi>c</mi><mo>)</mo><mi>d</mi><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mi>a</mi><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>b</mi><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi>c</mi><mi>x</mi><mo>+</mo><mi>C</mi><msubsup><mo fence="false">∣</mo><mi>l</mi><mi>r</mi></msubsup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>(</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mi>a</mi><msup><mi>r</mi><mn>3</mn></msup><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>b</mi><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mi>c</mi><mi>r</mi><mo>+</mo><mi>C</mi><mo>)</mo><mo>−</mo><mo>(</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mi>a</mi><msup><mi>l</mi><mn>3</mn></msup><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>b</mi><msup><mi>l</mi><mn>2</mn></msup><mo>+</mo><mi>c</mi><mi>l</mi><mo>+</mo><mi>C</mi><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>)</mo><mo>(</mo><mn>2</mn><mi>a</mi><mo>(</mo><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mi>l</mi><mi>r</mi><mo>+</mo><msup><mi>l</mi><mn>2</mn></msup><mo>)</mo><mo>+</mo><mn>3</mn><mi>b</mi><mo>(</mo><mi>l</mi><mo>+</mo><mi>r</mi><mo>)</mo><mo>+</mo><mn>6</mn><mi>c</mi><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>)</mo><mo>(</mo><mn>2</mn><mi>a</mi><msup><mi>l</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>a</mi><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>a</mi><mi>l</mi><mi>r</mi><mo>+</mo><mn>3</mn><mi>b</mi><mi>l</mi><mo>+</mo><mn>3</mn><mi>b</mi><mi>r</mi><mo>+</mo><mn>6</mn><mi>c</mi><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>)</mo><mo>(</mo><mo>(</mo><mi>a</mi><msup><mi>l</mi><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>l</mi><mo>+</mo><mi>c</mi><mo>)</mo><mo>+</mo><mo>(</mo><mi>a</mi><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>r</mi><mo>+</mo><mi>c</mi><mo>)</mo><mo>+</mo><mo>(</mo><mi>a</mi><msup><mi>l</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>a</mi><mi>l</mi><mi>r</mi><mo>+</mo><mi>a</mi><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>b</mi><mi>l</mi><mo>+</mo><mn>2</mn><mi>b</mi><mi>r</mi><mo>+</mo><mn>4</mn><mi>c</mi><mo>)</mo><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>)</mo><mo>(</mo><mi>f</mi><mo>(</mo><mi>l</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>r</mi><mo>)</mo><mo>+</mo><mn>4</mn><mo>(</mo><mi>a</mi><mo>(</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><msup><mo>)</mo><mn>2</mn></msup><mo>+</mo><mi>b</mi><mo>(</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>c</mi><mo>)</mo><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>)</mo><mo>(</mo><mi>f</mi><mo>(</mo><mi>l</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>r</mi><mo>)</mo><mo>+</mo><mn>4</mn><mi>f</mi><mo>(</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo>)</mo><mo>)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} \int_{l}^{r}f(x)dx
&amp;=\int_{l}^{r}(ax^2+bx+c)dx
\\ &amp;=\frac{1}{3}ax^3+\frac{1}{2}bx^2+cx+C\Big|_l^r
\\&amp;=(\frac{1}{3}ar^3+\frac{1}{2}br^2+cr+C)-(\frac{1}{3}al^3+\frac{1}{2}bl^2+cl+C)
\\&amp;=\frac{1}{6}(r-l)(2a(r^2+lr+l^2)+3b(l+r)+6c)
\\&amp;=\frac{1}{6}(r-l)(2al^2+2ar^2+2alr+3bl+3br+6c)
\\&amp;=\frac{1}{6}(r-l)((al^2+bl+c)+(ar^2+br+c)+(al^2+2alr+ar^2+2bl+2br+4c))
\\&amp;=\frac{1}{6}(r-l)(f(l)+f(r)+4(a(\frac{l+r}{2})^2+b(\frac{l+r}{2})+c))
\\&amp;=\frac{1}{6}(r-l)(f(l)+f(r)+4f(\frac{l+r}{2}))
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:18.892037em;vertical-align:-9.196018499999997em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:9.696018500000001em;"><span style="top:-11.696018500000001em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span><span style="top:-9.1626285em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"></span></span><span style="top:-6.841473500000002em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"></span></span><span style="top:-4.534033500000003em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"></span></span><span style="top:-2.226593500000002em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"></span></span><span style="top:0.08084649999999727em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"></span></span><span style="top:2.4382864999999967em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"></span></span><span style="top:4.795726499999998em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:9.196018499999997em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:9.696018500000001em;"><span style="top:-11.696018500000001em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span><span style="top:-9.1626285em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.167985em;"><span style="top:-1.955985em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.561985em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.167985em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6500149999999999em;"><span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.222277em;"><span style="top:-2.0002850000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span><span style="top:-3.6208850000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6997149999999999em;"><span></span></span></span></span></span></span></span></span><span style="top:-6.841473500000002em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span><span style="top:-4.534033500000003em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">6</span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span><span style="top:-2.226593500000002em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">6</span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span><span style="top:0.08084649999999727em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mclose">)</span></span></span><span style="top:2.4382864999999967em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mclose">)</span></span></span><span style="top:4.795726499999998em;"><span class="pstrut" style="height:3.414292em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:9.196018499999997em;"><span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>于是我们就解决了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 部分的曲边梯形面积.</p>
<p>下面考虑近似的边界。我们在处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 时，可以先用上面给出的公式算出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r],[l,\frac{l+r}{2}],[\frac{l+r}{2},r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 三部分曲边梯形的近似面积。 若左右两边的曲边梯形近似面积和总的曲边梯形近似面积差值小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">eps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span>，则返回，否则两边递归求解。 这就是“自适应”的方法。一般代码实现会涉及到一些常数以及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">eps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span> 的精度在传递过程中需不断提高的问题，具体参考代码.</p>
<p>【代码】</p>
<pre><code class="language-cpp">inline double simpson ( double a,double b )
{
    double c=(a+b)*0.5;
    return (f(a)+f(b)+4.0*f(c))*(b-a)/6.0;
}
inline double ars ( double a,double b,double eps )
{
    double c=(a+b)*0.5,mid=simpson(a,b),l=simpson(a,c),r=simpson(c,b);
    if ( fabs(l+r-mid)&lt;=15*eps ) return l+r+(l+r-mid)/15.0;
    return ars(a,c,eps*0.5)+ars(c,b,eps*0.5); 
}
</code></pre>
<p>simpson的例题较少，一般有两种考查方式：</p>
<ol>
<li>结合<strong>数学分析</strong>进行考查.</li>
</ol>
<p>【例题】luogu P4526 【模板】自适应辛普森法2</p>
<p>【题解】分析指数函数性质即可.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
long double a;
inline long double f ( long double x ) { return pow(x,a/x-x); }
inline long double simpson ( long double a,long double b )
{
	long double c=(a+b)*0.5;
	return (f(a)+f(b)+4.0*f(c))*(b-a)/6.0;
}
inline long double ars ( long double a,long double b,long double eps )
{
	long double c=(a+b)*0.5,mid=simpson(a,b),l=simpson(a,c),r=simpson(c,b);
	if ( fabs(l+r-mid)&lt;=15*eps ) return l+r+(l+r-mid)/15.0;
	return ars(a,c,eps*0.5)+ars(c,b,eps*0.5); 
}
int main()
{
	scanf(&quot;%LF&quot;,&amp;a);
	if ( a&lt;0 ) puts(&quot;orz&quot;);
	else printf(&quot;%.5LF\n&quot;,ars(1e-7,15,1e-7));
	return 0;
}
</code></pre>
<ol start="2">
<li>结合<strong>计算几何</strong>其他内容（如相交圆）进行考查.</li>
</ol>
<p>【例题】luogu P4207 「NOI2005」月下柠檬树</p>
<p>【题解】</p>
<p>动手画画应该就明白了吧……这里只给出网上的一张经典图片：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/e4ki4y14.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/e4ki4y14.png" loading="lazy"></figure>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const double eps=1e-6;
typedef std::pair&lt;double,double&gt; P;
#define fst first
#define snd second
#define G(x,y) std::make_pair(x,y)
struct Line
{
	P s,t;
	double k,b;
	Line(){}
	Line(P _s,P _t){s=_s;t=_t;k=(s.snd-t.snd)/(s.fst-t.fst);b=s.snd-s.fst*k;}
	inline double f ( double x ) { return k*x+b; }
}L[10000];
int n,m;double H[10000],alpha;P C[10000];
double sina,cosa,tana;
inline void add ( P a,P b )
{
	double sina=(a.snd-b.snd)/(b.fst-a.fst),cosa=sqrt(1-pow(sina,2));
	L[++m]=Line(G(a.fst+a.snd*sina,a.snd*cosa),G(b.fst+b.snd*sina,b.snd*cosa));
}
inline double f ( double x )
{
	double res=0;
	for ( int i=1;i&lt;=m;i++ ) if ( L[i].s.fst&lt;=x and x&lt;=L[i].t.fst ) res=std::max(res,L[i].f(x));
	for ( int i=1;i&lt;=n;i++ ) if ( C[i].fst-C[i].snd&lt;=x and x&lt;=C[i].fst+C[i].snd ) res=std::max(res,sqrt(pow(C[i].snd,2)-pow(x-C[i].fst,2)));
	return res;
}
inline double simpson ( double a,double b )
{
	long double c=(a+b)*0.5;
	return (f(a)+f(b)+4.0*f(c))*(b-a)/6.0;
}
inline double ars ( double a,double b,double eps )
{
	long double c=(a+b)*0.5,mid=simpson(a,b),l=simpson(a,c),r=simpson(c,b);
	if ( fabs(l+r-mid)&lt;=15*eps ) return l+r+(l+r-mid)/15.0;
	return ars(a,c,eps*0.5)+ars(c,b,eps*0.5); 
}
inline int cmp ( double x ) { return (fabs(x)&lt;eps) ? 0 : ( x&gt;0 ? 1 : -1 ) ; }
int main()
{
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;alpha);
	for ( int i=1;i&lt;=n+1;i++ ) scanf(&quot;%lf&quot;,&amp;H[i]),H[i]+=H[i-1];
	for ( int i=1;i&lt;=n;i++ ) scanf(&quot;%lf&quot;,&amp;C[i].snd);
	alpha=tan(alpha);
	P p=G(H[n+1]/alpha,0);
	double Lmin=2e9,Rmax=0;
	Rmax=std::max(Rmax,p.fst);
	C[n].fst=H[n]/alpha;
	double x=C[n].fst;
	double r=C[n].snd;
	Lmin=std::min(Lmin,x-r);
	Rmax=std::max(Rmax,x+r);
	if ( x+r&lt;p.fst )
	{
		double l=pow(r,2)/(p.fst-x);
		L[++m]=Line(G(x+l,sqrt(pow(r,2)-pow(l,2))),p);
	}
	for ( int i=n-1;i;i-- )
	{
		C[i].fst=H[i]/alpha;x=C[i].fst;r=C[i].snd;
		Lmin=std::min(Lmin,x-r);Rmax=std::max(Rmax,x+r);
		if ( cmp(C[i+1].fst-x-fabs(C[i+1].snd-r))&gt;0 ) add(C[i],C[i+1]);
	}
	return !printf(&quot;%.2lf\n&quot;,2*ars(Lmin,Rmax,eps));
}
</code></pre>
<h2 id="二-仿射变换与矩阵">二、仿射变换与矩阵</h2>
<p>从本专题起已经进入计算几何的冷门内容，下述两个算法均参考刘汝佳著作《算法竞赛入门经典——训练指南》.</p>
<p><a href="https://baike.baidu.com/item/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/4289056?fr=aladdin">仿射变换的定义</a></p>
<p>简单来说，仿射变换就是线性变换与平移的组合.</p>
<p><a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/5904192">线性变换的定义</a></p>
<p>简单来说，线性变换就是旋转、放缩等基本变换.</p>
<p>高中选修数学中有提及关于此部分的内容，提及了用矩阵来表示变换（其实本质是因为向量本身就是矩阵的一种形式）.</p>
<p>现在给出具体的做法：</p>
<p>我们用矩阵：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}x\\y\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> 表示点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</p>
<p>那么有（下列变换一律采用左乘的形式）：</p>
<p>变换一：旋转 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 度（角度一律按照高中数学课本定义）对应的矩阵为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}\cos{\alpha}&amp;-\sin{\alpha}\\\sin{\alpha}&amp;\cos{\alpha}\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>.</p>
<p>变换二：放缩至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 倍对应的矩阵为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>k</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>k</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}k&amp;0\\0&amp;k\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>.</p>
<p>其余线性变换均可用上述变换复合得成，例如反射即为放缩至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 倍。</p>
<p>但注意到：平移无法被表示。于是我们引入第三维参数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，进行平移变换，有：</p>
<p>用矩阵：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}x\\y\\1\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span> 表示点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</p>
<p>变换一：旋转 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 度对应的矩阵为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}\cos{\alpha}&amp;-\sin{\alpha}&amp;0\\\sin{\alpha}&amp;\cos{\alpha}&amp;0\\0&amp;0&amp;1\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>变换二：放缩至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 倍对应的矩阵为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>k</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>k</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}k&amp;0&amp;0\\0&amp;k&amp;0\\0&amp;0&amp;1\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>变换三：平移 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>x</mi><mo separator="true">,</mo><mi>d</mi><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(dx,dy)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 对应的矩阵为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>y</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}1&amp;0&amp;dx\\0&amp;1&amp;dy\\0&amp;0&amp;1\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>于是我们就可以用矩阵乘法的形式表示所有变换了。</p>
<p>同时在这种做法下，我们也能真正地区分点与向量的区别，即第三维参数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时为向量，为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时为点。</p>
<p>这样同时也满足了点与向量的关系：</p>
<p>（1）向量+向量=向量</p>
<p>（2）点+向量=点</p>
<p>（3）点+点：无意义</p>
<p>上述做法被称为点的齐次坐标，若有兴趣的读者可自行查阅其余资料了解.</p>
<p>【例题】UVa 12303 Composite Transformations</p>
<p>【题解】</p>
<p>依题意，直接用仿射矩阵记录每次操作即可.</p>
<p>对于平面，应用三点式而非点法式储存. 使用点法式直接变换会导致答案错误，因为法向量无法按此规则变换，且平面外一点变换后与平面的相对位置关系改变.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const double eps=1e-8;
const double pi=acos(-1.0);
inline int dcmp ( double x ) { return fabs(x)&lt;eps ? 0 : ( x&lt;0 ? -1 : 1 ) ; }
struct matrix
{
	int n,m;double a[10][10];
	matrix(){}
	inline double * operator [] ( const int x ) { return a[x]; }
	inline void init ( int _n,int _m,bool flag )
	{
		n=_n;m=_m;
		for ( int i=1;i&lt;=n;i++ ) for ( int j=1;j&lt;=m;j++ ) a[i][j]=0;
		if ( flag ) for ( int i=1;i&lt;=n;i++ ) a[i][i]=1;
	}
	inline friend matrix operator * ( matrix A,matrix B )
	{
		matrix C;C.init(A.n,B.m,false);
		for ( int i=1;i&lt;=A.n;i++ ) for ( int k=1;k&lt;=B.m;k++ ) for ( int j=1;j&lt;=A.m;j++ ) C[i][k]+=A[i][j]*B[j][k];
		return C; 
	}
};
struct Point
{
	double x,y,z;
	Point(double _x=0,double _y=0,double _z=0){x=_x;y=_y;z=_z;}
	inline friend Point operator + ( Point u,Point v ) { return Point(u.x+v.x,u.y+v.y,u.z+v.z); }
	inline friend Point operator - ( Point u,Point v ) { return Point(u.x-v.x,u.y-v.y,u.z-v.z); }
	inline friend Point operator * ( Point u,double v ) { return Point(u.x*v,u.y*v,u.z*v); }
	inline friend Point operator / ( Point u,double v ) { return Point(u.x/v,u.y/v,u.z/v); }
	inline friend double operator * ( Point u,Point v ) { return u.x*v.x+u.y*v.y+u.z*v.z; }
	inline friend Point operator ^ ( Point u,Point v ) { return Point(u.y*v.z-u.z*v.y,u.z*v.x-u.x*v.z,u.x*v.y-u.y*v.x); }
	inline friend bool operator == ( Point u,Point v ) { return dcmp(u.x-v.x)==0 and dcmp(u.y-v.y)==0 and dcmp(u.z-v.z)==0; }
	inline double Len ( void ) { return sqrt(x*x+y*y+z*z); }
	inline Point unit ( void ) { return *this/Len(); }
} p[100000];
inline Point modify ( Point u,matrix A )
{
	matrix B;B.init(4,1,false);
	B[1][1]=u.x;B[2][1]=u.y;B[3][1]=u.z;B[4][1]=1;
	A=A*B;
	return Point(A[1][1],A[2][1],A[3][1]);
}
struct Plane { double a,b,c,d; } T[100000];
signed main()
{
	int n,m,Q;scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	for ( int i=1;i&lt;=n;i++ )
	{
		double a,b,c;
		scanf(&quot;%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c);
		p[i]=Point(a,b,c);
	}
	for ( int i=1;i&lt;=m;i++ ) scanf(&quot;%lf%lf%lf%lf&quot;,&amp;T[i].a,&amp;T[i].b,&amp;T[i].c,&amp;T[i].d);
	matrix Ans;Ans.init(4,4,true);
	while ( Q-- )
	{
		char op[20]={'\0'};scanf(&quot; %s&quot;,op);
		matrix trans;trans.init(4,4,true);
		if ( op[0]=='T' ) scanf(&quot;%lf%lf%lf&quot;,&amp;trans[1][4],&amp;trans[2][4],&amp;trans[3][4]);
		else if ( op[0]=='R' )
		{
			double a,b,c,d;scanf(&quot;%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
			Point P=Point(a,b,c).unit();
			a=P.x;b=P.y;c=P.z;d=d/180*pi;
			double Cos=cos(d),Sin=sin(d);
			trans[1][1]=(1-Cos)*a*a+Cos;trans[1][2]=(1-Cos)*a*b-Sin*c;trans[1][3]=(1-Cos)*a*c+Sin*b;
			trans[2][1]=(1-Cos)*b*a+Sin*c;trans[2][2]=(1-Cos)*b*b+Cos;trans[2][3]=(1-Cos)*b*c-Sin*a;
			trans[3][1]=(1-Cos)*c*a-Sin*b;trans[3][2]=(1-Cos)*c*b+Sin*a;trans[3][3]=(1-Cos)*c*c+Cos;
		}
		else if ( op[0]=='S' ) scanf(&quot;%lf%lf%lf&quot;,&amp;trans[1][1],&amp;trans[2][2],&amp;trans[3][3]);
		Ans=trans*Ans;
	}
	for ( int i=1;i&lt;=n;i++ ) p[i]=modify(p[i],Ans),printf(&quot;%.2lf %.2lf %.2lf\n&quot;,p[i].x,p[i].y,p[i].z);
	for ( int i=1;i&lt;=m;i++ )
	{
		double a=T[i].a,b=T[i].b,c=T[i].c,d=-T[i].d;
		double max=std::max(fabs(a),std::max(fabs(b),fabs(c)));
		Point P[4];
		if ( fabs(a)==max ) P[1]=Point(d/a,0,0),P[2]=Point((d-b)/a,1,0),P[3]=Point((d-c)/a,0,1);
		else if ( fabs(b)==max ) P[1]=Point(0,d/b,0),P[2]=Point(1,(d-a)/b,0),P[3]=Point(0,(d-c)/b,1);
		else P[1]=Point(0,0,d/c),P[2]=Point(1,0,(d-a)/c),P[3]=Point(0,1,(d-b)/c);
		for ( int i=1;i&lt;=3;i++ ) P[i]=modify(P[i],Ans);
		Point u=((P[3]-P[1])^(P[2]-P[1])).unit();
		printf(&quot;%.2lf %.2lf %.2lf %.2lf\n&quot;,u.x,u.y,u.z,-(u*P[1]));
	}
	return 0;
}
</code></pre>
<h1 id="day-6">Day 6</h1>
<h2 id="一-运动规划">一、运动规划</h2>
<p>运动规划是来自于机器人领域的一个问题，一般综合考查图论与计算几何，代码复杂，容易出错.</p>
<p>实际上，最短路模型是运动规划里最为简单、最为基础的内容. 下面的例题将会带来最短路与计算几何的结合内容.</p>
<p>【例题】UVa 11921 Save the Princess</p>
<p>【题解】</p>
<p>题意：给定平面上两点与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个障碍（障碍为圆形），求两点间的最短路径.</p>
<p><s>这是个最短路问题，直接上 SPFA 就完了.</s></p>
<p>这是一道典型的运动规划问题. 解决运动规划问题一般按照如下步骤：</p>
<h3 id="step-1-考虑将其转化为一般最短路模型求解">Step 1 考虑将其转化为一般最短路模型求解.</h3>
<p>显然随机游走的答案是不优的. 考虑实际应当怎么走.</p>
<p>显然最优路线一定是沿直线走或沿障碍物走.</p>
<h3 id="step-2-考虑连边">Step 2 考虑连边.</h3>
<p>在障碍物、起点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>、终点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 间连边，有以下四类：</p>
<p>① <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>−</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">S-T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 连边</p>
<p>② <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">S/T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 向障碍物连切线</p>
<p>③ 障碍物与障碍物连公切线</p>
<p>④ 同一障碍物上不同点连边</p>
<p>分别处理即可. 考虑如何处理.</p>
<p>第①类，只需判断线段是否与障碍物有交点.</p>
<p>第②类，作切线，转化为连线段，同①.</p>
<p>第③类，作切线，同②.</p>
<p>第④类，考虑障碍物上哪些点会被走到. 第②③类的点记录一下，按极角序排个序，相邻两个连边就可以了.</p>
<h3 id="step-3-考虑计算答案">Step 3 考虑计算答案.</h3>
<p>跑<s>你喜欢的最短路算法</s> SPFA 或 dijkstra 即可.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const double eps=1e-8;
const double pi=acos(-1);
inline int dcmp ( double x ) { return fabs(x)&lt;eps ? 0 : ( x&lt;0 ? -1 : 1 ) ; }
struct Vector
{
	double x,y;
	Vector(double _x=0,double _y=0){x=_x;y=_y;}
	inline friend Vector operator + ( Vector u,Vector v ) { return Vector(u.x+v.x,u.y+v.y); }
	inline friend Vector operator - ( Vector u,Vector v ) { return Vector(u.x-v.x,u.y-v.y); }
	inline friend Vector operator * ( Vector u,double v ) { return Vector(u.x*v,u.y*v); }
	inline friend Vector operator / ( Vector u,double v ) { return Vector(u.x/v,u.y/v); }
	inline friend double operator * ( Vector u,Vector v ) { return u.x*v.x+u.y*v.y; }
	inline friend double operator ^ ( Vector u,Vector v ) { return u.x*v.y-u.y*v.x; }
	inline friend bool operator == ( Vector u,Vector v ) { return dcmp(u.x-v.x)==0 and dcmp(u.y-v.y)==0; }
	inline friend bool operator &lt; ( Vector u,Vector v )
	{
		if ( dcmp(u.x-v.x)!=0 ) return dcmp(u.x-v.x)==-1;
		else return dcmp(u.y-v.y)==-1;
	}
	inline Vector rotate ( double rad ) { return Vector(x*cos(rad)-y*sin(rad),x*sin(rad)+y*cos(rad)); }
	inline double Len ( void ) { return sqrt(x*x+y*y); }
	inline double angle ( void ) { return atan2(y,x); }
	inline Vector unit ( void ) { return *this/Len(); }
}S,T;
struct Segment
{
	Vector s,t;
	Segment(Vector _s=Vector(),Vector _t=Vector()){s=_s;t=_t;}
	inline double Len ( void ) { return (t-s).Len(); }
	inline double dist_line ( Vector u ) { return fabs((u-s)^(u-t))/Len(); }
	inline double dist_segment ( Vector u )
	{
		if ( s==t ) return (u-s).Len();
		Vector A=u-s,B=u-t;
		if ( dcmp((t-s)*A)==-1 ) return A.Len();
		else if ( dcmp((t-s)*B)==1 ) return B.Len();
		else return fabs(A^B)/Len();
	}
};
struct Line
{
	Vector p,v;
	Line(Vector _p=Vector(),Vector _v=Vector()){p=_p;v=_v;}
	inline Vector OnLine ( Vector u ) { return p+v*((v*(u-p))/(v*v)); } 
};
struct Circle
{
	Vector O;
	double r;
	Circle(Vector _O=Vector(),double _r=0){O=_O;r=_r;}
	inline Vector point ( double rad ) { return O+Vector(cos(rad),sin(rad))*r; }
	inline int On_Cricle ( Vector p ) { return dcmp((p-O).Len()-r)==0; }
	inline int Tangent_Point ( Vector p,Vector *res )
	{
		double d=(O-p).Len();
		if ( dcmp(d-r)==-1 ) return 0;
		else if ( dcmp(d-r)==0 )
		{
			res[0]=(O-p).rotate(pi/2);
			return 1;
		}
		else
		{
			double angle=asin(r/d);
			res[0]=(O-p).rotate(-angle);
			res[1]=(O-p).rotate(angle);
			return 2;
		}
	}
}C[100000];
inline int Tangent_Circle ( Circle u,Circle v,Segment *res )
{
	if ( u.r&lt;v.r ) std::swap(u,v);
	int cnt=0;
	double d=(u.O-v.O).Len(),del=fabs(u.r-v.r),sum=u.r+v.r;
	if ( del&gt;d ) return 0; 
	double rad=(v.O-u.O).angle(),theta=acos(del/d);
	res[cnt++]=Segment(u.point(rad+theta),v.point(rad+theta));
	res[cnt++]=Segment(u.point(rad-theta),v.point(rad-theta));
	if ( dcmp(d-sum)==0 ) res[cnt++]=Segment(u.point(rad),v.point(rad+pi));
	else
	{
		double angle=acos(sum/d);
		res[cnt++]=Segment(u.point(rad+angle),v.point(rad+angle+pi));
		res[cnt++]=Segment(u.point(rad-angle),v.point(rad-angle+pi));
	}
	return cnt;
}
struct edge { int v,nxt;double w; } e[100000];
int e_cnt,h[100000],n;
inline void addedge ( int u,int v,double w )
{
	e[++e_cnt].nxt=h[u];e[h[u]=e_cnt].v=v;e[e_cnt].w=w;
	e[++e_cnt].nxt=h[v];e[h[v]=e_cnt].v=u;e[e_cnt].w=w;
}
inline double Get_Angle ( double rad )
{
	while ( rad&lt;0 ) rad+=2*pi;
	while ( rad&gt;2*pi ) rad-=2*pi;
	return std::min(rad,2*pi-rad);
}
std::vector&lt;Vector&gt; Points;
std::map&lt;Vector,int&gt; map;
inline int Get_Id ( Vector p )
{
	if ( !map.count(p) ) Points.push_back(p),map[p]=(int)Points.size()-1;
	return map[p];
}
const double inf=1e12;
double dis[100000];
bool vis[100000];
inline int On_Circles ( Vector p )
{
	int res=0;
	for ( int i=1;i&lt;=n;i++ ) if ( C[i].On_Cricle(p) ) res++;
	return res;
}
inline void Add_Segment ( Segment segment,int cnt )
{
	for ( int i=1;i&lt;=n;i++ )
	{
		double d=segment.dist_segment(C[i].O);
		if ( dcmp(d-C[i].r)==-1 or ( dcmp(d-C[i].r)==0 and cnt--==0 ) ) return;
	}
	int u=Get_Id(segment.s),v=Get_Id(segment.t);
	if ( u&gt;=0 and v&gt;=0 and u!=v ) addedge(u,v,segment.Len());
}
inline void Add_Tangent ( Vector p )
{
	for ( int i=1;i&lt;=n;i++ )
	{
		Vector res[2];int cnt=C[i].Tangent_Point(p,res);
		for ( int j=0;j&lt;cnt;j++ ) Add_Segment(Segment(p,Line(p,res[j]).OnLine(C[i].O)),1);
	}
}
struct Double
{
	double val;
	Double(double _val=0){val=_val;}
	inline friend bool operator == ( Double x,Double y ) { return dcmp(x.val-y.val)==0; }
	inline friend bool operator &lt; ( Double x,Double y ) { return dcmp(x.val-y.val)==-1; }
};
inline double solve ( void )
{
	int s=Get_Id(S),t=Get_Id(T);
	Add_Segment(Segment(S,T),0);
	Add_Tangent(S);Add_Tangent(T);
	for ( int i=1;i&lt;n;i++ ) for ( int j=i+1;j&lt;=n;j++ )
	{
		Segment res[4];int cnt=Tangent_Circle(C[i],C[j],res);
		for ( int k=0;k&lt;cnt;k++ ) Add_Segment(res[k],2);
	}
	for ( int i=1;i&lt;=n;i++ )
	{
		std::vector&lt;double&gt; Angle;
		for ( Vector p:Points ) if ( C[i].On_Cricle(p) ) Angle.push_back((p-C[i].O).angle());
		std::sort(Angle.begin(),Angle.end());
		Angle.resize(unique(Angle.begin(),Angle.end())-Angle.begin());
		if ( (int)Angle.size()&lt;2 ) continue;
		Angle.push_back(Angle[0]);
		for ( int j=1;j&lt;(int)Angle.size();j++ )
		{
			double dist=C[i].r*Get_Angle(Angle[j]-Angle[j-1]);
			int u=Get_Id(C[i].point(Angle[j])),v=Get_Id(C[i].point(Angle[j-1]));
			if ( u&gt;=0 and v&gt;=0 and u!=v ) addedge(u,v,dist);
		}
	}
	for ( int i=0;i&lt;(int)Points.size();i++ ) dis[i]=inf,vis[i]=false;
	std::queue&lt;int&gt; q;q.push(s);dis[s]=0;vis[s]=true;
	while ( !q.empty() )
	{
		int u=q.front();q.pop();vis[u]=false;
		if ( On_Circles(Points[u])&gt;=2 ) continue;
		for ( int i=h[u];i;i=e[i].nxt ) if ( dis[e[i].v]&gt;dis[u]+e[i].w )
		{
			dis[e[i].v]=dis[u]+e[i].w;
			if ( !vis[e[i].v] ) q.push(e[i].v),vis[e[i].v]=true;
		}
	}
	return dis[t];
}
signed main()
{
	int Q;scanf(&quot;%d&quot;,&amp;Q);
	for ( int Case=1;Case&lt;=Q;Case++ )
	{
		scanf(&quot;%lf%lf%lf%lf%d&quot;,&amp;S.x,&amp;S.y,&amp;T.x,&amp;T.y,&amp;n);
		for ( int i=1;i&lt;=n;i++ ) scanf(&quot;%lf%lf%lf&quot;,&amp;C[i].O.x,&amp;C[i].O.y,&amp;C[i].r);
		printf(&quot;Case %d: %.8lf\n&quot;,Case,solve());
		for ( int i=0;i&lt;(int)Points.size();i++ ) h[i]=0;
		Points.clear();map.clear();e_cnt=0;
	}
	return 0;
}
</code></pre>
<h1 id="day-7">Day 7</h1>
<h2 id="一-例题">一、例题</h2>
<p>【例题】DTOJ 4198 「JOISC 2018 Day1」栅栏</p>
<p>【题解】</p>
<p>还是按照运动规划的一般思路分析，考虑转化为最短路模型.</p>
<p>考虑连边。显然有三种连边：</p>
<p>①栅栏与栅栏连边</p>
<p>②栅栏与牧场连边</p>
<p>③牧场与牧场连边</p>
<p>第①类，需要分类讨论栅栏间的最短距离：垂线段、端点连线.</p>
<p>第②类，放上官方题解的一张图：</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/qwprosg1.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/qwprosg1.png" loading="lazy"></figure>
<p>这就是九大类情况.</p>
<p>此外还有三种形式的连边：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1b0f4ejf.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/1b0f4ejf.png" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/1ha4pspa.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/1ha4pspa.png" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/wsdsiu39.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/wsdsiu39.png" loading="lazy"></p>
<p>分类讨论即可.</p>
<p>第三类即直接连边.</p>
<p>考虑答案的计算.</p>
<p>显然要求一个多边形，能够包裹住牧场.</p>
<p>也就是说，牧场应在多边形内部.</p>
<p>判定多边形内部常用射线法，因此任意作一条射线 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">OM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>.</p>
<p>连边时判定与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">OM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 的相交情况，最后跑最短路时令交点数量为奇数即可.</p>
<p>具体细节参考代码.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const double eps=1e-8;
const double inf=1e9;
const double pi=acos(-1);
inline int dcmp ( double x ) { return fabs(x)&lt;eps ? 0 : ( x&lt;0 ? -1 : 1 ) ; }
int n,S;double dis[1000][1000][2],Dis[1000][1000][2];
struct Vector
{
	double x,y;
	Vector(double _x=0,double _y=0){x=_x;y=_y;}
	inline friend Vector operator + ( Vector u,Vector v ) { return Vector(u.x+v.x,u.y+v.y); }
	inline friend Vector operator - ( Vector u,Vector v ) { return Vector(u.x-v.x,u.y-v.y); }
	inline friend Vector operator * ( Vector u,double v ) { return Vector(u.x*v,u.y*v); }
	inline friend Vector operator / ( Vector u,double v ) { return Vector(u.x/v,u.y/v); }
	inline friend double operator * ( Vector u,Vector v ) { return u.x*v.x+u.y*v.y; }
	inline friend double operator ^ ( Vector u,Vector v ) { return u.x*v.y-u.y*v.x; }
	inline friend bool operator == ( Vector u,Vector v ) { return dcmp(u.x-v.x)==0 and dcmp(u.y-v.y)==0; }
	inline friend bool operator &lt; ( Vector u,Vector v )
	{
		if ( dcmp(u.x-v.x)!=0 ) return dcmp(u.x-v.x)==-1;
		else return dcmp(u.y-v.y)==-1;
	}
	inline Vector rotate ( double rad ) { return Vector(x*cos(rad)-y*sin(rad),x*sin(rad)+y*cos(rad)); }
	inline double length ( void ) { return sqrt(x*x+y*y); }
	inline double angle ( void ) { return atan2(y,x); }
	inline Vector unit ( void ) { return *this/length(); }
};
struct Segment
{
	Vector s,t;
	Segment(Vector _s=Vector(),Vector _t=Vector()){s=_s;t=_t;}
	inline double length ( void ) { return (t-s).length(); }
	inline Vector dist_segment ( Vector u )
	{
		double val=((t-s)*(u-s))/length()/length();
		if ( val&lt;0 ) return s;
		if ( val&gt;1 ) return t;
		else return s+(t-s)*val;
	}
}Line_M,L[200];
inline bool ifsect ( Segment u,Segment v )
{
	return dcmp(((v.s-u.s)^(u.t-u.s))*((v.t-u.s)^(u.t-u.s)))&lt;0 and dcmp(((u.s-v.s)^(v.t-v.s))*((u.t-v.s)^(v.t-v.s)))&lt;=0;
}
inline bool ifsectbound ( Segment p )
{
	if ( ifsect(p,Segment(Vector(-S,-S),Vector(-S,S))) ) return true;
	if ( ifsect(p,Segment(Vector(-S,-S),Vector(S,-S))) ) return true;
	if ( ifsect(p,Segment(Vector(-S,S),Vector(S,S))) ) return true;
	if ( ifsect(p,Segment(Vector(S,-S),Vector(S,S))) ) return true;
	if ( ifsect(p,Segment(Vector(-S,-S),Vector(S,S))) ) return true;
	if ( ifsect(p,Segment(Vector(S,-S),Vector(-S,S))) ) return true;
	return false;
}
inline void Solve_Fences ( Segment u,Segment v,int x ,int y )
{
	Vector pos;bool w=false;
	dis[x][y][0]=dis[x][y][1]=inf;
	
	pos=u.dist_segment(v.s);
	w=ifsect(Line_M,Segment(v.s,pos))^ifsect(Line_M,Segment(u.s,pos));
	if ( !ifsectbound(Segment(pos,v.s)) ) dis[x][y][w]=std::min(dis[x][y][w],(v.s-pos).length());
	
	pos=u.dist_segment(v.t);
	w=ifsect(Line_M ,v)^ifsect(Line_M,Segment(pos,v.t))^ifsect(Line_M,Segment(u.s,pos));
	if ( !ifsectbound(Segment(pos,v.t)) ) dis[x][y][w]=std::min(dis[x][y][w],(v.t-pos).length());

	pos=v.dist_segment(u.s);
	w=ifsect(Line_M,Segment(u.s,pos))^ifsect(Line_M,Segment(v.s,pos));
	if ( !ifsectbound(Segment(pos,u.s)) ) dis[x][y][w]=std::min(dis[x][y][w],(u.s-pos).length());

	pos=v.dist_segment(u.t);
	w=ifsect(Line_M,u)^ifsect(Line_M,Segment(u.t,pos))^ifsect(Line_M,Segment(v.s,pos));
	if ( !ifsectbound(Segment(pos,u.t)) ) dis[x][y][w]=std::min(dis[x][y][w],(u.t-pos).length());
}

int main()
{
	srand(time(NULL));scanf(&quot;%d%d&quot;,&amp;n,&amp;S);
	double Angle=2*pi*rand()/RAND_MAX;
	Line_M=Vector(500*cos(Angle),500*sin(Angle));
	for ( int i=1,X1,Y1,X2,Y2;i&lt;=n;i++ ) scanf(&quot;%d%d%d%d&quot;,&amp;X1,&amp;Y1,&amp;X2,&amp;Y2),L[i]=Segment(Vector(X1,Y1),Vector(X2,Y2));
	L[++n]=Segment(Vector(S,S),Vector(S+eps,S));
	L[++n]=Segment(Vector(S,-S),Vector(S+eps,-S));
	L[++n]=Segment(Vector(-S,S),Vector(-S-eps,S));
	L[++n]=Segment(Vector(-S,-S),Vector(-S-eps,-S));
	for ( int i=1;i&lt;=n;i++ )
	{
		Dis[i][i][1]=dis[i][i][1]=inf;
		for ( int j=i+1;j&lt;=n;j++ )
		{
			Solve_Fences(L[i],L[j],i,j);
			for ( int k=0;k&lt;2;k++ ) Dis[i][j][k]=Dis[j][i][k]=dis[j][i][k]=dis[i][j][k];
		}
	}
	double Ans=inf;
	for ( int i=1;i&lt;=n;i++ )
	{
		for ( int j=1;j&lt;i;j++ ) for ( int k=j+1;k&lt;i;k++ ) for ( int p=0;p&lt;2;p++ ) for ( int q=0;q&lt;2;q++ )
			Ans=std::min(Ans,Dis[j][k][p^q^1]+dis[i][j][p]+dis[i][k][q]);
		for ( int j=1;j&lt;=n;j++ ) for ( int k=1;k&lt;=n;k++ ) for ( int p=0;p&lt;2;p++ ) for ( int q=0;q&lt;2;q++ )
			Dis[j][k][p^q]=std::min(Dis[j][k][p^q],Dis[i][j][p]+Dis[i][k][q]);
	}
	return !printf(&quot;%.10lf\n&quot;,Ans);
}
</code></pre>
]]></content>
    </entry>
</feed>