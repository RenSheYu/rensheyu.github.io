<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2020 寒假专题训练：计算几何 Part 1 | _RSY_&#39;s blog</title>
<link rel="shortcut icon" href="https://rensheyu.github.io/favicon.ico?v=1582719821286">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://rensheyu.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="2020 寒假专题训练：计算几何 Part 1 | _RSY_&#39;s blog - Atom Feed" href="https://rensheyu.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="Day1
一、凸包
凸包属于计算几何的基本内容，在此不进行讲解，只选择几道题目来研究。
【例题】DTOJ 4212 旅行规划
【题解】
此类不太好用线段树之类的数据结构维护的题一般都可以考虑分块.
分块后发现题意即为维护一个凸包. 直接维护..." />
    <meta name="keywords" content="专题" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://rensheyu.github.io">
  <img class="avatar" src="https://rensheyu.github.io/images/avatar.png?v=1582719821286" alt="">
  </a>
  <h1 class="site-title">
    _RSY_&#39;s blog
  </h1>
  <p class="site-description">
    滚落沙尘，泛生浮光。掠影千年，奔走四方。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              2020 寒假专题训练：计算几何 Part 1
            </h2>
            <div class="post-info">
              <span>
                20200226
              </span>
              <span>
                32 min read
              </span>
              
                <a href="https://rensheyu.github.io/subject/" class="post-tag">
                  # 专题
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="day1">Day1</h1>
<h2 id="一-凸包">一、凸包</h2>
<p>凸包属于计算几何的基本内容，在此不进行讲解，只选择几道题目来研究。</p>
<p>【例题】DTOJ 4212 旅行规划</p>
<p>【题解】</p>
<p>此类不太好用线段树之类的数据结构维护的题一般都可以考虑分块.</p>
<p>分块后发现题意即为维护一个凸包. 直接维护即可.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
inline int read(void)
{
	int x = 0; char ch; bool f = true;
	while ( !isdigit(ch = getchar()) )if ( ch == '-' )f = false;
	for ( x = ch ^ 48; isdigit(ch = getchar());)x = ( x &lt;&lt; 1 ) + ( x &lt;&lt; 3 ) + ( ch ^ 48 );
	return f ? x : -x;
}
const long long inf = 10000000000000000LL;
const int maxn = 100000 + 10;
const int maxs = 500 + 10;
int n, s, cnt, bl[maxn], L[maxs], R[maxs], st[maxs], p[maxs][maxs], tot[maxs];
long long a[maxn], fst[maxs], d[maxs], add[maxs];
inline double calc(int x, int y) { return 1.0 *( a[y] - a[x] ) / ( y - x ); }
inline void build(int x)
{
	int tp = 1; st[tp] = L[x];
	for ( int i = L[x] + 1; i &lt;= R[x]; i++ )
	{
		while ( tp &gt;= 2 and calc(st[tp - 1], st[tp]) &lt; calc(st[tp - 1], i) ) tp--;
		st[++tp] = i;
	}
	st[0] = 0; st[tp + 1] = n + 1; tot[x] = tp;
	for ( int i = 0; i &lt;= tp + 1; i++ ) p[x][i] = st[i];
}
inline long long solve(int x)
{
	if ( x == 0 || x == n + 1 ) return -inf;
	return a[x] + fst[bl[x]] + d[bl[x]] * ( x - L[bl[x]] ) + add[bl[x]];
}
inline long long query(int x)
{
	int l = 1, r = tot[x];
	while ( l &lt;= r )
	{
		int mid = ( l + r ) &gt;&gt; 1;
		long long t1 = solve(p[x][mid - 1]), t2 = solve(p[x][mid]), t3 = solve(p[x][mid + 1]);
		if ( t1 &lt; t2 and t2 &lt; t3 ) l = mid + 1;
		else if ( t1 &gt; t2 and t2 &gt; t3 ) r = mid - 1;
		else return t2;
	}
	return -1;
}
signed main()
{
	n = read();
	for ( int i = 1; i &lt;= n; i++ ) a[i] = a[i - 1] + read();
	a[0] = a[n + 1] = -inf;
	s = (int) floor(sqrt(n) + 0.5); cnt = ( n - 1 ) / s + 1;
	for ( int i = 1; i &lt;= n; i++ ) bl[i] = ( i - 1 ) / s + 1;
	for ( int i = 1; i &lt;= cnt; i++ ) L[i] = ( i - 1 ) * s + 1, R[i] = std::min(n, i * s);
	for ( int i = 1; i &lt;= cnt; i++ ) build(i);
	for ( int m = read(); m; m-- )
	{
		int op = read(), x = read(), y = read(), l = bl[x], r = bl[y];
		if ( op )
		{
			long long ans = -inf;
			if ( l == r )
			{
				for ( int i = x; i &lt;= y; i++ ) ans = std::max(ans, solve(i));
			}
			else
			{
				for ( int i = l + 1; i &lt;= r - 1; i++ ) ans = std::max(ans, query(i));
				for ( int i = x; i &lt;= R[l]; i++ ) ans = std::max(ans, solve(i));
				for ( int i = L[r]; i &lt;= y; i++ ) ans = std::max(ans, solve(i));
			}
			printf(&quot;%lld\n&quot;, ans);
		}
		else
		{
			long long k = read();
			if ( l == r )
			{
				long long res = fst[l];
				for ( int i = L[l]; i &lt;= R[l]; i++ ) a[i] += res, res += d[l], a[i] += add[l];
				fst[l] = d[l] = add[l] = 0;
				res = k;
				for ( int i = x; i &lt;= y; i++ ) a[i] += res, res += k;
				build(l);
				res = k * ( y - x + 1 );
				for ( int i = y + 1; i &lt;= R[l]; i++ ) a[i] += res;
				build(r);
				for ( int i = l + 1; i &lt;= cnt; i++ ) add[i] += res;
			}
			else
			{
				long long res = k * ( L[l + 1] - x + 1 );
				for ( int i = l + 1; i &lt;= r - 1; i++ ) fst[i] += res, d[i] += k, res += s * k;
				res = fst[l];
				for ( int i = L[l]; i &lt;= R[l]; i++ ) a[i] += res, res += d[l], a[i] += add[l];
				fst[l] = d[l] = add[l] = 0;
				res = k;
				for ( int i = x; i &lt;= std::min(y, R[l]); i++ ) a[i] += res, res += k;
				build(l);
				res = fst[r];
				for ( int i = L[r]; i &lt;= R[r]; i++ ) a[i] += res, res += d[r], a[i] += add[r];
				fst[r] = d[r] = add[r] = 0;
				res = k * ( L[r] - x + 1 );
				for ( int i = L[r]; i &lt;= y; i++ ) a[i] += res, res += k;
				res = k * ( y - x + 1 );
				for ( int i = y + 1; i &lt;= R[r]; i++ ) a[i] += res;
				build(r);
				for ( int i = r + 1; i &lt;= cnt; i++ ) add[i] += res;
			}
		}
	}
	return 0;
}
</code></pre>
<p>【例题】DTOJ 4515 Generator 3</p>
<p>【题解】</p>
<p>看到这么大的数据就知道肯定跟造数据方式有关……</p>
<p>考虑观察数据的生成。如果有做过类似题，不难发现会存在循环节。循环的方式是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ρ</span></span></span></span> 型的. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 均按此方式循环，循环节小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ρ</span></span></span></span> 前面一部分暴力处理，考虑解决两个环的问题.</p>
<p>思考凸包的做法。维护上凸壳、下凸壳。显然 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 相同时，只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的最大最小值有用。在环上倍增维护即可.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
inline int read ( void )
{
	int x=0;char ch;bool f=true;
	while ( !isdigit(ch=getchar()) ) if ( ch=='-' ) f=false;
	for ( x=ch^48;isdigit(ch=getchar()); ) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
	return f ? x : -x ;
}
const int maxn=200000+10;
int X0,Y0,ax,ay,bx,by,px,py,vis[maxn],sx,sy,tx,ty,st,tp,s[maxn&lt;&lt;2],min[maxn&lt;&lt;1][35],max[maxn&lt;&lt;1][35],tot;
std::vector&lt;int&gt; C[maxn],Ax,Ay;
std::pair&lt;int,int&gt; p[maxn&lt;&lt;2];
long long n,ans;
inline long long cp ( std::pair&lt;int,int&gt; p1,std::pair&lt;int,int&gt; p2,std::pair&lt;int,int&gt; p3 )
{
	return 1LL*(p3.second-p1.second)*(p2.first-p1.first)-1LL*(p2.second-p1.second)*(p3.first-p1.first);
}
inline int getx ( int x )
{
	if ( x&lt;sx ) return Ax[x];
	else return Ax[(x-sx)%tx+sx];
}
inline int gety ( int y )
{
	if ( y&lt;sy ) return Ay[y];
	else return Ay[(y-sy)%ty+sy];
}
inline void init ( int id )
{
	int m=2*(int)C[id].size();
	for ( int i=0;i&lt;m;i++ ) min[i][0]=max[i][0]=C[id][i%(int)C[id].size()];
	for ( int j=1;(1&lt;&lt;j)&lt;=m;j++ ) for ( int i=0;i+(1&lt;&lt;j)&lt;=m;i++ )
		min[i][j]=std::min(min[i][j-1],min[i+(1&lt;&lt;(j-1))][j-1]),
		max[i][j]=std::max(max[i][j-1],max[i+(1&lt;&lt;(j-1))][j-1]);
}
inline int rmqmin ( int l,int r )
{
	int k=log2(r-l+1);
	return std::min(min[l][k],min[r-(1&lt;&lt;k)+1][k]);
}
inline int rmqmax ( int l,int r )
{
	int k=log2(r-l+1);
	return std::max(max[l][k],max[r-(1&lt;&lt;k)+1][k]);
}
signed main()
{
	X0=read();Y0=read();ax=read();ay=read();bx=read();by=read();px=read();py=read();std::cin&gt;&gt;n;
	memset(vis,-1,sizeof(vis));
	vis[X0]=0;Ax.push_back(X0);
	for ( int i=1,res=X0;i&lt;=(px&lt;&lt;1);i++ )
	{
		res=(1LL*res*ax+bx)%px;
		if ( ~vis[res] ) { sx=vis[res];tx=i-vis[res];break; }
		vis[res]=i;Ax.push_back(res);
	}
	memset(vis,-1,sizeof(vis));
	vis[Y0]=0;Ay.push_back(Y0);
	for ( int i=1,res=Y0;i&lt;=(py&lt;&lt;1);i++ )
	{
		res=(1LL*res*ay+by)%py;
		if ( ~vis[res] ) { sy=vis[res];ty=i-vis[res];break; }
		vis[res]=i;Ay.push_back(res);
	}
	memset(vis,-1,sizeof(vis));
	int g=std::__gcd(tx,ty);st=std::max(sx,sy);
	for ( int i=0;i&lt;g;i++ )
	{
		int tmp=st+i;
		for ( int j=0,k;j&lt;tx/g;j++ ) k=getx(tmp),C[i].push_back(k),vis[k]=(int)C[i].size()-1,tmp=(tmp-st+ty)%tx+st;
	}
	for ( int i=0;i&lt;g;i++ )
	{
		init(i);
		for ( int j=st+i;j&lt;ty+st and j&lt;n;j+=g )
			if ( n&gt;=1LL*ty*(int)C[i].size()+j )
				p[++tot]=std::make_pair(rmqmin(0,(int)C[i].size()-1),gety(j)),
				p[++tot]=std::make_pair(rmqmax(0,(int)C[i].size()-1),gety(j));
			else
			{
				int k=vis[getx(j)],ed=(n-j-1)/ty;
				p[++tot]=std::make_pair(rmqmin(k,k+ed),gety(j)),
				p[++tot]=std::make_pair(rmqmax(k,k+ed),gety(j));
			}
	}
	for ( int i=0;i&lt;st;i++ ) p[++tot]=std::make_pair(getx(i),gety(i));
	std::sort(p+1,p+tot+1);
	s[++tp]=1;
	for ( int i=2;i&lt;=tot;i++ )
	{
		while ( tp&gt;1 and cp(p[s[tp-1]],p[i],p[s[tp]])&lt;=0 ) tp--;
		s[++tp]=i;
	}
	for ( int i=tp;i&gt;=3;i-- ) ans+=cp(p[s[1]],p[s[i]],p[s[i-1]]);
	tp=0;
	s[++tp]=1;
	for ( int i=2;i&lt;=tot;i++ )
	{
		while ( tp&gt;1 and cp(p[s[tp-1]],p[i],p[s[tp]])&gt;=0 ) tp--;
		s[++tp]=i;
	}
	for ( int i=3;i&lt;=tp;i++ ) ans+=cp(p[s[1]],p[s[i-1]],p[s[i]]);
	return !printf(&quot;%lld\n&quot;,ans);
}
</code></pre>
<p>【例题】DTOJ 2197 「FJWC2015」信用卡凸包</p>
<p>【题解】</p>
<p>根据小学奥数计算此类曲边图形的周长方法，将圆弧部分与线段部分拆开考虑.</p>
<p>显然圆心角之和为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>π</mi></mrow><annotation encoding="application/x-tex">2\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>，因此圆弧部分总长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>π</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">2\pi r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>.</p>
<p>考虑将线段部分拼接在一起。向内平移至圆心处即可.</p>
<p>即每张卡拆成四个角的圆心，算凸包长度即可.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const double pi=acos(-1);
struct Graph
{
	struct Vector
	{
		double x,y;
		Vector(double _x=0,double _y=0){x=_x;y=_y;}
		inline friend Vector operator - ( const Vector &amp;u,const Vector &amp;v ) { return Vector(u.x-v.x,u.y-v.y); }
		inline friend double operator ^ ( const Vector &amp;u,const Vector &amp;v ) { return u.x*v.y-u.y*v.x; }
		inline double length ( void ) { return sqrt(x*x+y*y); }
	}st[1000000];int tp;
	std::vector&lt;Vector&gt; E;
	inline void add ( double x,double y ) { E.push_back(Vector(x,y)); }
	inline double solve ( void )
	{
		double ans=0;
		std::sort(E.begin(),E.end(),[&amp;](const Vector &amp;u,const Vector &amp;v){return fabs(u.x-v.x)&lt;1e-8 ? u.y&lt;v.y : u.x&lt;v.x;});
		for ( auto p:E )
		{
			while ( tp&gt;1 and ((p-st[tp-1])^(st[tp]-st[tp-1]))&lt;=0 ) tp--;
			st[++tp]=p;
		}
		for ( int i=2;i&lt;=tp;i++ ) ans+=(st[i]-st[i-1]).length();
		tp=0;
		for ( auto p:E )
		{
			while ( tp&gt;1 and ((p-st[tp-1])^(st[tp]-st[tp-1]))&gt;=0 ) tp--;
			st[++tp]=p;
		}
		for ( int i=2;i&lt;=tp;i++ ) ans+=(st[i]-st[i-1]).length();
		return ans;
	}
}G;
int n;double a,b,r,R,alpha;
signed main()
{
	scanf(&quot;%d%lf%lf%lf&quot;,&amp;n,&amp;a,&amp;b,&amp;r);a-=2*r;b-=2*r;
	R=sqrt(a*a+b*b)*0.5;alpha=atan(a/b);
	for ( int i=1;i&lt;=n;i++ )
	{
		double x,y,theta;scanf(&quot;%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;theta);
		G.add(x+R*cos(theta+alpha),y+R*sin(theta+alpha));
		G.add(x+R*cos(theta-alpha),y+R*sin(theta-alpha));
		G.add(x-R*cos(theta+alpha),y-R*sin(theta+alpha));
		G.add(x-R*cos(theta-alpha),y-R*sin(theta-alpha));
	}
	return !printf(&quot;%.2lf\n&quot;,G.solve()+2*pi*r);
}
</code></pre>
<h2 id="二-旋转卡壳">二、旋转卡壳</h2>
<p>先给个网上的参考读音：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/u5rg1iz7.png" alt="" loading="lazy"></figure>
<p>然后是输入法现状：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rq3c8dvb.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/gjquwtck.png" alt="" loading="lazy"></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><msub><mn>3</mn><msup><mn>3</mn><mrow><msub><mn>3</mn><mn>3</mn></msub><msup><mn>3</mn><msub><mn>3</mn><msup><mn>3</mn><msub><mn>3</mn><mn>3</mn></msub></msup></msub></msup></mrow></msup></msub></msup></mrow><annotation encoding="application/x-tex">2^{3_{3^{3_3{3^{3_{3^{3_{3}}}}}}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2508029999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2508029999999999em;"><span style="top:-3.4996950000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:3.3332928571428573em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.8666099999999999em;"><span style="top:-3.8666100000000005em;margin-right:0.1em;"><span class="pstrut" style="height:3.45922em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">3</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29964em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.45922em;"><span style="top:-3.4592199999999997em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:3.05183em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.05183em;"><span style="top:-3.05183em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29964em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.70703em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9884928571428571em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>考虑有关距离的一般定义，都有个垂直. 所以我们需要一个垂直.</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/q1v6yx9v.png" alt="" loading="lazy"></figure>
<p>现在我们有个垂直。于是距离就很显然了：在凸包用一组平行线转一圈，平行线间距离最大值即为凸包的距离.</p>
<p><s>（到此结束上代码）</s></p>
<p>显然平行线不会超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 组（自己看图）。因此效率是正确的.</p>
<p>考虑如何实现转一圈的过程. 用点来转显然非常麻烦，还需要做垂直.</p>
<p>我们考虑将平行线旋转一下：</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.luogu.com.cn/upload/image_hosting/f0vbdgwt.png" alt="" loading="lazy"></figure>
<p>现在看起来好多了！现在开始观察性质.</p>
<p>我们看看其它点到这条边的距离有什么性质：逆时针呈单峰函数！</p>
<p>于是就有这么一个做法：逆时针按顺序枚举边，点用推指针的方式找到（显然点是单调的），判定可以用面积法。效率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>PS：其实当坐标绝对值范围较小时，凸包上的点往往个数很少，因此以下算法活跃涌现：随机化、暴力枚举……<s>（好像都能过）</s></p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
struct Vector
{
	int x,y;
	Vector(int _x=0,int _y=0){x=_x;y=_y;}
	inline friend Vector operator + ( Vector u,Vector v ) { return Vector(u.x+v.x,u.y+v.y); }
	inline friend Vector operator - ( Vector u,Vector v ) { return Vector(u.x-v.x,u.y-v.y); }
	inline friend long long operator ^ ( Vector u,Vector v ) { return 1LL*u.x*v.y-1LL*u.y*v.x; }
}G[50010],p[50010];
int n,tp,st[50010],m=-1;
std::set&lt;int&gt; s;
inline long long dis ( Vector u,Vector v ) { return 1LL*(u.x-v.x)*(u.x-v.x)+1LL*(u.y-v.y)*(u.y-v.y); }
signed main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for ( int i=1;i&lt;=n;i++ ) scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y);
	std::sort(p+1,p+n+1,[&amp;](const Vector &amp;p1,const Vector &amp;p2){return p1.x==p2.x ? p1.y&lt;p2.y : p1.x&lt;p2.x;});
	tp=0;st[++tp]=1;
	for ( int i=2;i&lt;=n;i++ )
	{
		while ( tp&gt;1 and ((p[i]-p[st[tp-1]])^(p[st[tp]]-p[st[tp-1]]))&lt;=0 ) tp--;
		st[++tp]=i;
	}
	for ( int i=1;i&lt;=tp;i++ ) G[++m]=p[st[i]],s.insert(st[i]);
	tp=0;st[++tp]=1;
	for ( int i=2;i&lt;=n;i++ )
	{
		while ( tp&gt;1 and ((p[i]-p[st[tp-1]])^(p[st[tp]]-p[st[tp-1]]))&gt;=0 ) tp--;
		st[++tp]=i;
	}
	for ( int i=tp;i;i-- ) if ( !s.count(st[i]) ) G[++m]=p[st[i]];
	std::reverse(G,G+m+1);G[++m]=G[0];
	long long ans=dis(G[0],G[1]);
	for ( int i=0,j=2;i&lt;m;i++ )
	{
		while ( ((G[i+1]-G[i])^(G[j]-G[i]))&lt;((G[i+1]-G[i])^(G[j+1]-G[i])) ) j=(j+1)%m;
		ans=std::max(ans,std::max(dis(G[i],G[j]),dis(G[i+1],G[j])));
	}
	return !printf(&quot;%lld\n&quot;,ans);
}
</code></pre>
<p>【例题】DTOJ 2165 Beauty Contest (dist)</p>
<p>【题解】板子.</p>
<h2 id="三-扫描线">三、扫描线</h2>
<p>扫描线是处理二维平面问题的一个重要工具，在数据结构中也有重要应用，常与线段树或平衡树相结合. 此处结合几道例题进行讲解.</p>
<p>【例题】矩形面积并</p>
<p>【题目描述】给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">n(n \leq 10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 个长宽平行于坐标轴的矩形，求面积之并.</p>
<p>【题解】</p>
<p>考虑这么一种情况：</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.luogu.com.cn/upload/image_hosting/jdthqfgr.png" alt="" loading="lazy"></figure>
<p>解决面积并一类问题，在数据范围较小的时候有一个很漂亮的做法：容斥. 由于是求并的面积，可以容斥计算.</p>
<p>但这题 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的范围高达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，显然需要一种优秀的做法.</p>
<p>考虑我们小学怎么算这种图形的面积：割补法. 我们考虑割补. 由于是矩形，因此边界都在格子上，比较好算.</p>
<p>我们考虑竖着切割. 继续放图：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.luogu.com.cn/upload/image_hosting/gdrxymtg.png" alt="" loading="lazy"></figure>
<p>切割完，我们需要求的就变成每个小矩形的面积.</p>
<p>考虑先处理在哪里切割. 切割的地方显然应该是矩形左右两边. 因此我们需要把每个矩形的两边离散化后存下来（本题数据较小可以不用离散化）.</p>
<p>每个小矩形的面积应为相邻两条直线的距离乘上直线上被覆盖的长度. 显然可以用数据结构维护被覆盖的区域.</p>
<p>因此将每个矩形拆解为在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 处插入区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[y_1,y_2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 与在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 处删除区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[y_1,y_2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 两个操作，从左往右扫一遍，用线段树维护即可.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
inline int read ( void )
{
	int x=0;char ch;bool f=true;
	while ( !isdigit(ch=getchar()) ) if ( ch=='-' ) f=false;
	for ( x=ch^48;isdigit(ch=getchar()); ) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
	return f ? x : -x ;
}
const int maxn=200000+10;
int n;long long ans;
std::vector&lt;std::pair&lt;int,int&gt;&gt; I[maxn],D[maxn];
#define ls (k&lt;&lt;1)
#define rs (k&lt;&lt;1|1)
#define mid ((l+r)&gt;&gt;1)
struct tree { int res,sum; } t[maxn&lt;&lt;2];
inline void pushup ( int k,int l,int r )
{
	if ( t[k].res ) t[k].sum=r-l+1;
	else if ( l==r ) t[k].sum=0;
	else t[k].sum=t[ls].sum+t[rs].sum;
}
inline void update ( int k,int l,int r,int ql,int qr,int f )
{
	if ( ql&lt;=l and r&lt;=qr ) { t[k].res+=f;pushup(k,l,r);return; }
	if ( ql&lt;=mid ) update(ls,l,mid,ql,qr,f);
	if ( qr&gt;mid ) update(rs,mid+1,r,ql,qr,f);
	pushup(k,l,r);
}
#undef ls
#undef rs
#undef mid
signed main()
{
//	freopen(&quot;.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;.out&quot;,&quot;w&quot;,stdout);
	n=read();
	for ( int i=1;i&lt;=n;i++ )
	{
		int X1=read()+100000,X2=read()+100000,Y1=read(),Y2=read();
		I[X1].push_back(std::make_pair(Y1,Y2-1));
		D[X2].push_back(std::make_pair(Y1,Y2-1));
	}
	for ( int lst=0,x=0;x&lt;=200000;x++ ) if ( (int)I[x].size() or (int)D[x].size() )
	{
		ans+=1LL*(x-lst)*t[1].sum;
		for ( auto p:I[x] ) update(1,-100000,100000,p.first,p.second,1);
		for ( auto p:D[x] ) update(1,-100000,100000,p.first,p.second,-1);
		lst=x;
	}
	return !printf(&quot;%lld\n&quot;,ans);
}
</code></pre>
<p>以上即为扫描线的基本应用. 除了计算几何，一些偏序问题也可以转化到二维平面上用扫描线的思想解决.</p>
<p>【例题】DTOJ 4428 团</p>
<p>这是一个很经典的问题. 不难发现题目要求的即为一个转了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>45</mn></mrow><annotation encoding="application/x-tex">45</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">5</span></span></span></span> 度的正方形内点数的最大值.</p>
<p>考虑旋转坐标系，转化为正常的正方形。旋转时注意处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 的变化.</p>
<p>现在来解决这个问题. 根据上一题的经验，采用扫描线算法.</p>
<p>由于本题维护的是一个正方形，因此扫描线应该维护的是一段区间.</p>
<p>另外一个方向同理用线段树维护最值即可. 注意应将点的权值转化为区间加，答案统计线段树的每个叶子节点会被多少个点对应的区间覆盖到.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int Lmin=-200000000,Rmax=100000000,maxn=300000+10;
std::pair&lt;int,int&gt; p[maxn];
struct tree { int max,tag,ls,rs; } t[maxn*100];
int n,R,ans,tot,Root;
#define mid ((l+r)&gt;&gt;1)
#define ls t[k].ls
#define rs t[k].rs
inline void pushdown ( int k )
{
	if ( !ls ) ls=++tot;
	if ( !rs ) rs=++tot;
	t[ls].max+=t[k].tag;t[ls].tag+=t[k].tag;
	t[rs].max+=t[k].tag;t[rs].tag+=t[k].tag;
	t[k].tag=0;
}
inline void update ( int &amp;k,int l,int r,int ql,int qr,int val )
{
	if ( !k ) k=++tot;
	if ( ql&lt;=l and r&lt;=qr ) { t[k].max+=val;t[k].tag+=val;return; }
	if ( t[k].tag ) pushdown(k);
	if ( ql&lt;=mid ) update(ls,l,mid,ql,qr,val);
	if ( qr&gt;mid ) update(rs,mid+1,r,ql,qr,val);
	t[k].max=std::max(t[ls].max,t[rs].max);
}
signed main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;R);
	for ( int i=1,x,y;i&lt;=n;i++ ) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),p[i].first=x+y,p[i].second=x-y;
	std::sort(p+1,p+n+1);
	for ( int l=1,r=0;l&lt;=n;l++ )
	{
		while ( r&lt;n and p[r+1].first-p[l].first&lt;=R ) r++,update(Root,Lmin,Rmax,p[r].second-R,p[r].second,1);
		ans=std::max(ans,t[Root].max);update(Root,Lmin,Rmax,p[l].second-R,p[l].second,-1);
	}
	return !printf(&quot;%d\n&quot;,ans);
}
</code></pre>
<h1 id="day2">Day2</h1>
<h2 id="一-半平面交">一、半平面交</h2>
<p>定义：</p>
<p>半平面：一条直线将一个平面分为两个半平面. 这里我们统一规定，直线为有向直线（点向式，即用一个点和一个向量表示直线），我们需要的为直线的左侧（沿直线方向的左侧）.</p>
<p>多边形的核：多边形中的一块区域，该区域中的任意一个点都能直接看到多边形的任意一条边（视线与边相切也可以），即每条边上任意一点与其连线与其它边均无交点.</p>
<p>不难发现，将多边形的边逆时针遍历一遍，每条边所在直线（注意是有向的）左侧的半平面的交即为多边形的核.</p>
<p>下面介绍半平面交 SI 算法：</p>
<h3 id="step-0补全边界">Step 0：补全边界</h3>
<p>由于处理问题，可以先补全边界，防止出现无限大的半平面交.</p>
<h3 id="step-1排序">Step 1：排序</h3>
<p>将每条直线按方向（不是倾斜角）的极角序排序，同方向（注意不是平行）的直线取最左侧那条即可.</p>
<h3 id="step-2加入直线">Step 2：加入直线</h3>
<p>考虑每次新加入一条直线，如何维护已有直线及交点.</p>
<p>分四类讨论有：</p>
<p>① 加入红色线时，与之前最后一条直线产生交点.</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.luogu.com.cn/upload/image_hosting/qppzcw3w.png" alt="" loading="lazy"></figure>
<p>② 加入红色线时，与倒数第二条线有交点。此时应在加入前先判断，删除最后几条不必要的直线.</p>
<figure data-type="image" tabindex="7"><img src="https://cdn.luogu.com.cn/upload/image_hosting/qcw9eagt.png" alt="" loading="lazy"></figure>
<p>③ 加入新直线时，与首尾直线均有交点，因此两边都需要维护判定.</p>
<figure data-type="image" tabindex="8"><img src="https://cdn.luogu.com.cn/upload/image_hosting/prtwazgc.png" alt="" loading="lazy"></figure>
<p>④ 与第二条直线有交点，从而需要删去第一条直线.</p>
<figure data-type="image" tabindex="9"><img src="https://cdn.luogu.com.cn/upload/image_hosting/x3n0m78f.png" alt="" loading="lazy"></figure>
<p>具体的判定都是判交点在直线的左右侧. 可以用叉积的正负性判断.</p>
<p>综上所述，我们需要维护直线与交点，同时支持以下操作：</p>
<ol>
<li>
<p>删除最前端</p>
</li>
<li>
<p>删除最后端</p>
</li>
<li>
<p>从最后端加入</p>
</li>
</ol>
<p>于是就可以用双端队列维护. 具体实现参考例题.</p>
<p>【例题】DTOJ 1687 「CQOI2006」凸多边形</p>
<p>【题解】</p>
<p>把凸多边形拆成直线，半平面交即可.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
const double eps=1e-6,lim=1e3;
inline int dcmp ( double x ) { return fabs(x)&lt;eps ? 0 : ( x&lt;0 ? -1 : 1 ) ; }
struct Vector
{
	double x,y;
	Vector(double _x=0,double _y=0){x=_x;y=_y;}
	inline friend Vector operator + ( Vector u,Vector v ) { return Vector(u.x+v.x,u.y+v.y); }
	inline friend Vector operator - ( Vector u,Vector v ) { return Vector(u.x-v.x,u.y-v.y); }
	inline friend Vector operator * ( Vector u,double v ) { return Vector(u.x*v,u.y*v); }
	inline friend Vector operator / ( Vector u,double v ) { return Vector(u.x/v,u.y/v); }
	inline friend double operator * ( Vector u,Vector v ) { return u.x*v.x+u.y*v.y; }
	inline friend double operator ^ ( Vector u,Vector v ) { return u.x*v.y-u.y*v.x; }
	inline double calc_angle ( void ) { return atan2(y,x); }
}Q2[30000],p[30000];
struct Line
{
	Vector s,t;double A;
	Line(Vector _s=Vector(),Vector _t=Vector()){s=_s;t=_t-_s;A=t.calc_angle();}
	inline friend bool operator &lt; ( Line u,Line v )
	{
		if ( dcmp(u.A-v.A)!=0 ) return dcmp(u.A-v.A)==-1;
		return dcmp(u.t^(v.t+v.s-u.s))==-1;
	}
}L[30000],Q[30000];
inline bool PX ( Line u,Line v ) { return dcmp(u.t^v.t)==0; }
inline Vector JD ( Line u,Line v ) { return u.s+u.t*((v.t^(u.s-v.s))/(u.t^v.t)); }
inline bool OnRight ( Line u,Vector v ) { return dcmp(u.t^(v-u.s))&lt;0; }
int n,m,tot;
signed main()
{
	scanf(&quot;%d&quot;,&amp;tot);
	for ( int i=1;i&lt;=tot;i++ )
	{
		int cnt,X[100]={0},Y[100]={0};scanf(&quot;%d&quot;,&amp;cnt);
		for ( int i=1;i&lt;=cnt;i++ ) scanf(&quot;%d%d&quot;,&amp;X[i],&amp;Y[i]);
		for ( int i=2;i&lt;=cnt;i++ ) L[++n]=Line(Vector(X[i-1],Y[i-1]),Vector(X[i],Y[i]));
		L[++n]=Line(Vector(X[cnt],Y[cnt]),Vector(X[1],Y[1]));
	}
	Vector p1=Vector(-lim,-lim),p2=Vector(lim,-lim),p3=Vector(lim,lim),p4=Vector(-lim,lim);
	L[++n]=Line(p1,p2);L[++n]=Line(p2,p3);L[++n]=Line(p3,p4);L[++n]=Line(p4,p1);
	std::sort(L+1,L+n+1);
	int l=0,r=0;Q[0]=L[1];
	for ( int i=2;i&lt;=n;i++ ) if ( dcmp(L[i].A-L[i-1].A) )
	{
		if ( l&lt;r and ( PX(Q[l],Q[l+1]) or PX(Q[r],Q[r-1]) ) ) return !puts(&quot;0.000&quot;);
		while ( l&lt;r and OnRight(L[i],Q2[r-1]) ) r--;
		while ( l&lt;r and OnRight(L[i],Q2[l]) ) l++;
		Q[++r]=L[i];
		if ( l&lt;r ) Q2[r-1]=JD(Q[r],Q[r-1]);
	}
	while ( l&lt;r and OnRight(Q[l],Q2[r-1]) ) r--;
	while ( l&lt;r and OnRight(Q[r],Q2[l]) ) l++;
	if ( r-l&lt;=1 ) return !puts(&quot;0.000&quot;);
	Q2[r]=JD(Q[l],Q[r]);
	for ( int i=l;i&lt;=r;i++ ) p[++m]=Q2[i];
	double ans=p[m]^p[1];
	for ( int i=2;i&lt;=m;i++ ) ans+=p[i-1]^p[i];
	return !printf(&quot;%.3lf\n&quot;,ans*0.5);
}
</code></pre>
<p>【例题】DTOJ 2348 「SCOI2015」小凸想跑步</p>
<p>【题解】</p>
<p>考虑选取点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 使得面积最小的要求.</p>
<p>直接用向量叉积算面积，可以推出来一个式子，形式为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>x</mi><mo>+</mo><mi>B</mi><mi>y</mi><mo>+</mo><mi>C</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">Ax+By+C&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>.</p>
<p>看到这个式子应该非常熟悉，想起高中解几学的直线的一般式。显然直线的一侧即为半平面.</p>
<p>因此每个条件当成一个半平面，直接半平面交即可.</p>
<p>注意：选取点需要在多边形内，因此将多边形每条边也作为半平面的限制.</p>
<p>【代码】</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const double eps=1e-6;
inline int dcmp ( double x ) { return fabs(x)&lt;eps ? 0 : ( x&lt;0 ? -1 : 1 ) ; }
struct Vector
{
	double x,y;
	Vector(double _x=0,double _y=0){x=_x;y=_y;}
	inline friend Vector operator + ( Vector u,Vector v ) { return Vector(u.x+v.x,u.y+v.y); }
	inline friend Vector operator - ( Vector u,Vector v ) { return Vector(u.x-v.x,u.y-v.y); }
	inline friend Vector operator * ( Vector u,double v ) { return Vector(u.x*v,u.y*v); }
	inline friend Vector operator / ( Vector u,double v ) { return Vector(u.x/v,u.y/v); }
	inline friend double operator * ( Vector u,Vector v ) { return u.x*v.x+u.y*v.y; }
	inline friend double operator ^ ( Vector u,Vector v ) { return u.x*v.y-u.y*v.x; }
	inline double calc_angle ( void ) { return atan2(y,x); }
}Q2[200000],p[200000];
struct Line
{
	Vector s,t;double A;
	Line(Vector _s=Vector(),Vector _t=Vector()){s=_s;t=_t;A=t.calc_angle();}
	inline friend bool operator &lt; ( Line u,Line v )
	{
		if ( dcmp(u.A-v.A)!=0 ) return dcmp(u.A-v.A)==-1;
		return dcmp(u.t^(v.t+v.s-u.s))==-1;
	}
}L[200000],Q[200000];
inline bool PX ( Line u,Line v ) { return dcmp(u.t^v.t)==0; }
inline Vector JD ( Line u,Line v ) { return u.s+u.t*((v.t^(u.s-v.s))/(u.t^v.t)); }
inline bool OnRight ( Line u,Vector v ) { return dcmp(u.t^(v-u.s))&lt;0; }
int n,cnt,m;long long X[200000],Y[200000];
signed main()
{
	scanf(&quot;%d&quot;,&amp;n);double sum=0,ans=0;
	for ( int i=1;i&lt;=n;i++ ) scanf(&quot;%lld%lld&quot;,&amp;X[i],&amp;Y[i]),p[i]=Vector(X[i],Y[i]);
	X[n+1]=X[1];Y[n+1]=Y[1];p[n+1]=p[1];
	for ( int i=1;i&lt;=n;i++ ) L[++cnt]=Line(p[i],p[i+1]-p[i]),sum+=p[i]^p[i+1];
	for ( int i=2;i&lt;=n;i++ )
	{
		double a=X[2]-X[1]+X[i]-X[i+1];
		double b=Y[2]-Y[1]+Y[i]-Y[i+1];
		double c=X[2]*Y[1]+X[i]*Y[i+1]-X[1]*Y[2]-X[i+1]*Y[i];
		if ( dcmp(a)!=0 ) L[++cnt]=Line(Vector(0,c/a),Vector(-a,-b));
		else if ( dcmp(b)!=0 ) L[++cnt]=Line(Vector(-c/b,0),Vector(-a,-b));
	}
	std::sort(L+1,L+cnt+1);
	int l=0,r=0;Q[0]=L[1];
	for ( int i=2;i&lt;=cnt;i++ ) if ( dcmp(L[i].A-L[i-1].A) )
	{
		if ( l&lt;r and ( PX(Q[l],Q[l+1]) or PX(Q[r],Q[r-1]) ) ) { ans=0;goto E; }
		while ( l&lt;r and OnRight(L[i],Q2[r-1]) ) r--;
		while ( l&lt;r and OnRight(L[i],Q2[l]) ) l++;
		Q[++r]=L[i];
		if ( l&lt;r ) Q2[r-1]=JD(Q[r],Q[r-1]);
	}
	while ( l&lt;r and OnRight(Q[l],Q2[r-1]) ) r--;
	while ( l&lt;r and OnRight(Q[r],Q2[l]) ) l++;
	if ( r-l&lt;=1 ) { ans=0;goto E; }
	Q2[r]=JD(Q[l],Q[r]);
	for ( int i=l;i&lt;=r;i++ ) p[++m]=Q2[i];
	ans=p[m]^p[1];
	for ( int i=2;i&lt;=m;i++ ) ans+=p[i-1]^p[i];
	E:printf(&quot;%.4lf\n&quot;,ans/sum);
	return 0;
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#day1">Day1</a>
<ul>
<li><a href="#%E4%B8%80-%E5%87%B8%E5%8C%85">一、凸包</a></li>
<li><a href="#%E4%BA%8C-%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3">二、旋转卡壳</a></li>
<li><a href="#%E4%B8%89-%E6%89%AB%E6%8F%8F%E7%BA%BF">三、扫描线</a></li>
</ul>
</li>
<li><a href="#day2">Day2</a>
<ul>
<li><a href="#%E4%B8%80-%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4">一、半平面交</a>
<ul>
<li><a href="#step-0%E8%A1%A5%E5%85%A8%E8%BE%B9%E7%95%8C">Step 0：补全边界</a></li>
<li><a href="#step-1%E6%8E%92%E5%BA%8F">Step 1：排序</a></li>
<li><a href="#step-2%E5%8A%A0%E5%85%A5%E7%9B%B4%E7%BA%BF">Step 2：加入直线</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://rensheyu.github.io/subject-number-theory-3/">
              <h3 class="post-title">
                2020 寒假专题训练：数论 Part 3（Min_25筛坑待填）
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by 
<a href="https://github.com/getgridea/gridea" target="_blank"> &nbsp;Gridea</a>
  <a class="rss" href="https://rensheyu.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
